def get_input_parameters():
    """
    Получаем N

    :return: N, например: 14
    :rtype: int
    """

    number_n = int(input('Введите число: '))
    return number_n


def display_result(odd_numbers):
    """
    Выводим список нечётных чисел

    :param odd_numbers: список нечётных чисел, например: [1, 3, 5, 7, 9, 11, 13]
    :type odd_numbers: List[int]
    """
    print(f'\nСписок из нечётных чисел от 1 до N: {odd_numbers}')


def get_odd_numbers(number):
    """
    Получаем отсортированный по возрастанию список
    нечётных чисел от 1 до number.

    :param number: до какого числа нужно рассчитать, например: 14
    :type number: int

    :return: список нечётных чисел, например: [1, 3, 5, 7, 9, 11, 13]
    :rtype: List[int]
    """
    number_list = []
    for num in range(1, number + 1, 2):
        number_list.append(num)

    return number_list


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    number = get_input_parameters()  # получаем параметры
    odd_numbers = get_odd_numbers(number)  # получаем нечётные числа
    display_result(odd_numbers)  # выводим результат
 
 ****************************************
 
 def display_result(participants_names):
    """
    Выводим список имён участников в первый день

    :param participants_names: список имён участников, например: ["Артемий", "Влад", "Дима", "Женя"]
    :type participants_names: List[str]
    """
    print('Первый день:', participants_names)


def get_participants_names(names):
    """
    Получаем элементы списка только с чётными индексами.

    :param names: список имён, например: ["Артемий", "Борис", "Влад", "Гоша", "Дима", "Евгений", "Женя", "Захар"]
    :type names: List[str]

    :return: список имён с чётными индексами , например: ["Артемий", "Влад", "Дима", "Женя"]
    :rtype: List[str]
    """

    names_list_even_i = []
    for index in range(len(names)):
        if index % 2 == 0:
            names_list_even_i.append(names[index])

    return names_list_even_i







if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_participants_names и display_result
    participants_names = get_participants_names(
        ["Артемий", "Борис", "Влад", "Гоша", "Дима", "Евгений", "Женя", "Захар"]
    )  # получаем список имён с чётными индексами
    display_result(participants_names)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем набор клеток

    :return: набор клеток, например: [3, 0, 6, 2, 10]
    :rtype: List[int]
    """
    number_cells = int(input('Кол-во клеток: '))
    cells_list = []

    for num in range(number_cells):
        efficiency_cell = int(input(f'Эффективность {num + 1} клетки: '))
        cells_list.append(efficiency_cell)

    return cells_list


def display_result(cells):
    """
    Выводим список клеток у которых значение меньше индекса

    :param cells: набор клеток, например: [0, 2]
    :type cells: List[int]
    """
    print('\nНеподходящие значения:', end=' ')
    print(*cells, sep=' ')


def select_cells(cells):
    """
    Отбираем список клеток, у которых значение меньше индекса.

    :param cells: набор клеток, например: [3, 0, 6, 2, 10]
    :type cells: List[int]

    :return: набор подходящих клеток, например: [0, 2]
    :rtype: List[int]
    """
    unsuitable_cells = []

    for index, efficiency in enumerate(cells):
        if efficiency < index:
            unsuitable_cells.append(cells[index])

    return unsuitable_cells


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    cells = get_input_parameters()  # получаем параметры
    result_cells = select_cells(cells)  # отбираем клетки
    display_result(result_cells)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем список видеокарт

    :return: набор клеток, например: [3070, 2060, 3090, 3070, 3090]
    :rtype: List[int]
    """
    number_video_cards = int(input('Кол-во видеокарт: '))
    video_cards_list = []

    for num in range(number_video_cards):
        video_cards_model = int(input(f'{num + 1} Видеокарта: '))
        video_cards_list.append(video_cards_model)

    return video_cards_list


def display_result(old_video_cards, new_video_cards):
    """
    Выводим список оставшихся видеокарт

    :param old_video_cards: старый набор видеокарт, например: [3070, 2060, 3090, 3070, 3090]
    :type old_video_cards: List[int]
    :param new_video_cards: новый набор видеокарт, например: [3070, 2060, 3070]
    :type new_video_cards: List[int]
    """
    print('Старый список видеокарт:', end=' ')
    print(*old_video_cards, sep=', ')
    print('Новый список видеокарт:', end=' ')
    print(*new_video_cards, sep=', ')


def select_video_cards(video_cards):
    """
    Удаляем из списка видеокарт наибольшие элементы.

    :param video_cards: набор видеокарт, например: [3070, 2060, 3090, 3070, 3090]
    :type video_cards: List[int]

    :return: набор оставшихся видеокарт, например: [3070, 2060, 3070]
    :rtype: List[int]
    """
    new_video_cards = []
    old_model_video_cards = video_cards[0]

    for model_video_card in video_cards:
        if old_model_video_cards <= model_video_card:
            old_model_video_cards = model_video_card

    for model_v_c in video_cards:
        if model_v_c < old_model_video_cards:
            new_video_cards.append(model_v_c)

    return new_video_cards


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    video_cards = get_input_parameters()  # получаем параметры
    result_video_cards = select_video_cards(video_cards)  # удаляет наибольшие элементы.
    display_result(video_cards, result_video_cards)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем список фильмов, которые пользователь хочет добавить в "любимые"

    :return: добавляемые фильмы, например: ["Леон", "Безумный Макс", "Мементо", "Царь горы"]
    :rtype: List[str]
    """
    number_films = int(input('Сколько фильмов хотите добавить? '))
    films_list = []

    for _ in range(number_films):
        name_film = input('Введите название фильма: ')
        films_list.append(name_film)

    return films_list


def display_result(favorite_films, errors):
    """
    Выводим список ошибок и список любимых фильмов

    :param favorite_films: список любимых фильмов, например: ["Леон", "Мементо"]
    :type favorite_films: List[str]
    :param errors: список ненайденных фильмов, например: ["Безумный Макс", "Царь горы"]
    :type errors: List[str]
    """
    print()
    for film in errors:
        print(f'Ошибка: фильма {film} у нас нет :(')

    print('Ваш список любимых фильмов:', end=' ')
    print(*favorite_films, sep=', ')


def add_favorite_film(new_favorite_films, available_films):
    """
    Добавляем фильмы в список "любимых".

    :param new_favorite_films: фильмы, которые нужно добавить в "любимые",
           например: ["Леон", "Безумный Макс", "Мементо", "Царь горы"]
    :type new_favorite_films: List[str]
    :param available_films: фильмы, которые есть на киносайте,
           например: ["Леон", "Назад в будущее", "Мементо"]
    :type available_films: List[str]

    :return: Список фильмов в списке "любимых" и список не найденных фильмов,
             например: (["Леон", "Мементо"], ["Безумный Макс", "Царь горы"])
    :rtype: Tuple[List[str], List[str]]
    """

    favorite_films_user_list = []
    missing_films_list = []

    for index_favorite_films in range(len(new_favorite_films)):
        count_films = 0
        for index_available_films in range(len(available_films)):
            if new_favorite_films[index_favorite_films] == available_films[index_available_films]:
                count_films += 1

        if count_films == 1:
            favorite_films_user_list.append(new_favorite_films[index_favorite_films])
        else:
            missing_films_list.append(new_favorite_films[index_favorite_films])

    return favorite_films_user_list, missing_films_list


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    available_films = [
        "Крепкий орешек", "Назад в будущее", "Таксист",
        "Леон", "Богемская рапсодия", "Город грехов",
        "Мементо", "Отступники", "Деревня"
    ]
    new_favorite_films = get_input_parameters()  # получаем параметры
    favorite_films, errors = add_favorite_film(
        new_favorite_films,
        available_films
    )  # добавлем фильмы в список "любимых".
    display_result(favorite_films, errors)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем входное слово

    :return: входное слово, например: "привет"
    :rtype: str
    """

    word = input('Введите слово: ')

    return word


def display_result(number_unique_letters):
    """
    Выводим количество уникальных букв в слове

    :param number_unique_letters: количество уникальных букв в слове, например: 6
    :type number_unique_letters: int
    """
    print('Кол-во уникальных букв:', number_unique_letters)


def count_number_unique_letters(word):
    """
    Считаем количество уникальных букв в слове.

    :param word: входное слово, например: "привет"
    :type word: str

    :return: количество уникальных букв в слове, например: 6
    :rtype: int
    """
    letter_list = list(word)
    count_unique_letter = 0

    for symbol in letter_list:
        count_letter = 0
        for index in range(len(letter_list)):
            if symbol == letter_list[index]:
                count_letter += 1

        if count_letter == 1:
            count_unique_letter += 1

    return count_unique_letter


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    word = get_input_parameters()  # получаем параметры
    number_unique_letters = count_number_unique_letters(word)  # считаем количество уникальных букв.
    display_result(number_unique_letters)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем список весов контейнеров и вес нового контейнера
    Незабываем проверит данные: все числа целые и не превышают 200.

    :return: список весов контейнеров и вес нового контейнера,
             например: ([165, 163, 160, 160, 157, 157, 155, 154], 162)
    :rtype: Tuple[List[int], int]
    """
    number_containers = int(input('Кол-во контейнеров: '))
    count_right_containers = 0

    while True:
        weight_containers = int(input('Введите вес контейнера: '))
        if (weight_containers <= 0) or (weight_containers > 200):
            print('\nОшибка ввода: масса контейнеров не должна быть меньше или равна 0'
                  ' либо превышать 200 килограмм. \n')
        else:
            containers_list = [weight_containers]
            break

    while (count_right_containers + 1) != number_containers:
        weight_containers = int(input('Введите вес контейнера: '))
        if (weight_containers > containers_list[count_right_containers]) or \
                (weight_containers <= 0) or (weight_containers > 200):
            print('\nОшибка ввода: последовательность массы контейнеров не должна быть '
                  'возрастающей либо  меньше или равна 0, либо превышать 200 килограмм.\n')
        else:
            containers_list.append(weight_containers)
            count_right_containers += 1

    while True:
        new_container_weight = int(input('Введите вес нового контейнера: '))
        if (new_container_weight <= 0) or (new_container_weight > 200):
            print('\nОшибка ввода: масса контейнеров не должна быть меньше или равна 0'
                  ' либо превышать 200 килограмм. \n')
        else:
            break

    return containers_list, new_container_weight


def display_result(serial_number_new_container):
    """
    Выводим порядковый номер нового контейнера.

    :param serial_number_new_container: порядковый номер нового контейнера, например: 3
    :type serial_number_new_container: int
    """
    print('\nНомер, куда встанет новый контейнер:', serial_number_new_container)


def search_serial_number_new_container(list_container_weights, new_container_weight):
    """
    Ищем куда вставим новый контейнер.

    :param list_container_weights: список весов контейнеров, например: [165, 163, 160, 160, 157, 157, 155, 154]
    :type list_container_weights: List[int]
    :param new_container_weight: вес нового контейнера, например: 166
    :type new_container_weight: int

    :return: порядковый номер нового контейнера, например: 3
    :rtype: int
    """
    number_new_container = 0

    for index in range(len(list_container_weights)):
        if new_container_weight <= list_container_weights[index]:
            number_new_container = index + 2

    return number_new_container


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    list_container_weights, new_container_weight = get_input_parameters()  # получаем параметры
    # Ищем куда вставим новый контейнер.
    serial_number_new_container = search_serial_number_new_container(list_container_weights, new_container_weight)
    display_result(serial_number_new_container)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем сдвиг и начальны список

    :return: например: (3, [1, 4, -3, 0, 10])
    :rtype: Tuple[int, List[int]]
    """
    shift = int(input('Сдвиг: '))
    list_n = [1, 4, -3, 0, 10]
    print('Изначальный список: ', list_n)
    return shift, list_n


def display_result(shifted_list):
    """
    Выводим получившиеся список

    :param shifted_list: сдвинутый список, например: [5, 1, 2, 3, 4]
    :type shifted_list: List[int]
    """
    print('\nСдвинутый список:', shifted_list)


def shift_list(shift, original_list):
    """
    Сдвигаем список на определённое количество элементов в право

    :param shift: сдвиг: 3
    :type shift: int
    :param original_list: Исходный список: [1, 4, -3, 0, 10]
    :type original_list: List[int]

    :return: сдвинутый список, например: [5, 1, 2, 3, 4]
    :rtype: List[int]
    """

    new_list = [0] * len(original_list)
    temporary_i_zero_original_list = original_list[len(original_list) - shift]

    for index in range(len(original_list) - 1, -1, -1):
        new_list[index] = original_list[index - shift]
    new_list[0] = temporary_i_zero_original_list

    return new_list


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    shift, original_list = get_input_parameters()  # получаем параметры
    shifted_list = shift_list(shift, original_list)  # сдвигаем список.
    display_result(shifted_list)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем входное слово

    :return: например: abccba
    :rtype: str
    """
    word = input('Введите слово: ')

    return word


def display_result(is_palindrome):
    """
    Выводим информацию является ли строка палиндромом

    :param is_palindrome: является ли палиндромом, например: True
    :type is_palindrome: bool
    """
    if is_palindrome:
        print('\nСлово является палиндромом.')
    else:
        print('\nСлово не является палиндромом.')


def check_palindrome(word):
    """
    Проверяем является ли слово палиндромом.

    :param word: слово, например: abccba
    :type word: str

    :return: является ли слово палиндром, например: True
    :rtype: bool
    """
    list_word = []
    for symbol in word:
        list_word.append(symbol)

    list_word_inverse = []
    palindrome = False
    for index in range(len(list_word) - 1, -1, -1):
        list_word_inverse.append(list_word[index])

    if list_word == list_word_inverse:
        palindrome = True

    return palindrome


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    word = get_input_parameters()  # получаем параметры
    is_palindrome = check_palindrome(word)  # является ли слово палиндромом.
    display_result(is_palindrome)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем неотсортированный список чисел

    :return: неотсортированный список чисел, например: [1, 4, -3, 0, 10]
    :rtype: List[int]
    """
    original_list = [1, 4, -3, 0, 10]

    return original_list


def display_result(sorted_list):
    """
    Выводим отсортированный список

    :param sorted_list: отсортированный список, например: [-3, 0, 1, 4, 10]
    :type sorted_list: List[int]
    """
    print('Изначальный список: [1, 4, -3, 0, 10]')
    print('Отсортированный список:', sorted_list)


def sort_list(original_list):
    """
    Сортируем список

    :param original_list: Исходный список: [1, 4, -3, 0, 10]
    :type original_list: List[int]

    :return: отсортированный, например: [-3, 0, 1, 4, 10]
    :rtype: List[int]
    """

    for index_minimum_num in range(len(original_list)):
        for current_num in range(index_minimum_num, len(original_list)):
            if original_list[index_minimum_num] > original_list[current_num]:
                original_list[index_minimum_num], original_list[current_num] = original_list[current_num], \
                                                                                  original_list[index_minimum_num]

    return original_list


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    original_list = get_input_parameters()  # получаем параметры
    sorted_list = sort_list(original_list)  # сортируем список.
    display_result(sorted_list)  # выводим результат

 
 ****************************************
 
 import unittest

from task_01_list_gen.main import get_odd_numbers


class Test01GetOddNumbers(unittest.TestCase):
    def test_get_odd_numbers_boundary_conditions(self):
        """
        Проверяем граничные условия. При вводе 1 должна получиться последовательность [1]
        """
        odd_numbers = get_odd_numbers(1)
        self.assertEqual(odd_numbers, [1])

    def test_get_odd_numbers(self):
        """
        Проверяем обычный кейс. При вводе 14 должна получиться последовательность [1, 3, 5, 7, 9, 11, 13]
        """

        odd_numbers = get_odd_numbers(14)
        self.assertEqual(odd_numbers, [1, 3, 5, 7, 9, 11, 13])


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_02_tournament.main import get_participants_names


class Test02GetParticipantsNames(unittest.TestCase):
    def test_get_participants_names(self):
        """
        Проверяем обычный кейс. Выводим элементы списка только с чётными индексами.
        """
        participants_names = get_participants_names(["Артемий", "Борис", "Влад", "Гоша"])
        self.assertEqual(participants_names, ["Артемий", "Влад"])


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_03_cells.main import select_cells


class Test03SelectCells(unittest.TestCase):
    def test_select_cells(self):
        """
        Проверяем обычный кейс. При параметрах [5, 3, 0, 6, 2, 10, 4]  должны получить [0 2, 4]
        """
        cells = [3, 0, 6, 2, 10, 4]
        res_cells = select_cells(cells)
        self.assertEqual(res_cells, [0, 2, 4])

    def test_select_cells_no_result(self):
        """
        Проверяем обычный кейс. При параметрах [1, 2, 3]  должны получить []
        """
        cells = [1, 2, 3]
        res_cells = select_cells(cells)
        self.assertEqual(res_cells, [])


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest
from task_04_videocards.main import select_video_cards


class Test04SelectVideoCards(unittest.TestCase):
    def test_select_video_cards(self):
        """
        Проверяем обычный кейс. [3070, 2060, 3090, 3070, 3090]  должны получить [3070, 2060, 3070]
        """
        video_cards_list = [3070, 2060, 3090, 3070, 3090]
        new_video_cards_list = select_video_cards(video_cards_list)

        self.assertEqual(new_video_cards_list, [3070, 2060, 3070])

    def test_select_video_cards_no_result(self):
        """
        Проверяем обычный кейс. [3070, 3070]  должны получить []
        """
        video_cards_list = [3070, 3070]
        new_video_cards_list = select_video_cards(video_cards_list)

        self.assertEqual(new_video_cards_list, [])


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_05_movie.main import add_favorite_film


class Test05AddFavoriteFilm(unittest.TestCase):
    def test_add_favorite_film(self):
        """
        Проверяем обычный кейс. При вводе ["Леон", "Безумный Макс", "Мементо", "Царь горы"]
         должны получить (["Леон", "Мементо"], ["Безумный Макс", "Царь горы"])
        """
        available_films = [
            "Крепкий орешек", "Назад в будущее", "Таксист",
            "Леон", "Богемская рапсодия", "Город грехов",
            "Мементо", "Отступники", "Деревня"
        ]
        new_favorite_films = ["Леон", "Безумный Макс", "Мементо", "Царь горы"]

        favorite_films, errors = add_favorite_film(new_favorite_films,available_films )

        self.assertEqual(set(favorite_films), {"Леон", "Мементо"})
        self.assertEqual(set(errors), {"Безумный Макс", "Царь горы"})


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_06_word_analysis.main import count_number_unique_letters


class Test06CountNumberUniqueLetters(unittest.TestCase):
    def test_main_privet(self):
        """
        Проверяем обычный кейс. При вводе "привет"  должны получить "Кол-во уникальных букв: 6"
        """
        number_unique_letters = count_number_unique_letters("привет")

        self.assertEqual(number_unique_letters, 6)

    def test_main_lava(self):
        """
        Проверяем обычный кейс. При вводе "лава"  должны получить "Кол-во уникальных букв: 2"
        """
        number_unique_letters = count_number_unique_letters("лава")

        self.assertEqual(number_unique_letters, 2)


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_07_containers.main import search_serial_number_new_container


class Test07SearchSerialNumberNewContainer(unittest.TestCase):
    def test_main(self):
        """
        Проверяем обычный кейс. При вводе [165, 163, 160, 160, 157, 157, 155, 154] должны получить 3
        """
        list_container_weights = [165, 163, 160, 160, 157, 157, 155, 154]
        new_container_weight = 162

        serial_number_new_container = search_serial_number_new_container(list_container_weights, new_container_weight)

        self.assertEqual(serial_number_new_container, 3)


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_08_running_nums.main import shift_list


class Test08ShiftList(unittest.TestCase):
    def test_shift_list_1_step(self):
        """
        Проверяем обычный кейс. При вводе 1, [1, 2, 3, 4, 5] должны получить  [5, 1, 2, 3, 4]
        """
        print_result = shift_list(1, [1, 2, 3, 4, 5])
        self.assertEqual(print_result, [5, 1, 2, 3, 4])

    def test_shift_list_3_step(self):
        """
        Проверяем обычный кейс. При вводе 3, [1, 4, -3, 0, 10] должны получить [-3, 0, 10, 1, 4]
        """
        print_result = shift_list(3, [1, 4, -3, 0, 10])
        self.assertEqual(print_result, [-3, 0, 10, 1, 4])


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_09_word_analysis_2.main import check_palindrome


class Test09CheckPalindrome(unittest.TestCase):
    def test_check_palindrome_madam(self):
        """
        Проверяем обычный кейс. При вводе "мадам" True
        """
        is_palindrome = check_palindrome("мадам")
        self.assertEqual(is_palindrome, True)

    def test_check_palindrome_abccba(self):
        """
        Проверяем обычный кейс. При вводе "abccba" должны получить True
        """
        is_palindrome = check_palindrome("abccba")
        self.assertEqual(is_palindrome, True)

    def test_check_palindromen_abbd(self):
        """
        Проверяем обычный кейс. При вводе "abbd" должны получить False
        """
        is_palindrome = check_palindrome("abbd")
        self.assertEqual(is_palindrome, False)


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_10_sort.main import sort_list


class Test10Sort(unittest.TestCase):
    def test_sort_list(self):
        """
        Проверяем обычный кейс. При вводе [1, 4, -3, 0, 10] должны получить [-3, 0, 1, 4, 10]
        """
        sorted_list = sort_list([1, 4, -3, 0, 10])
        self.assertEqual(sorted_list, [-3, 0, 1, 4, 10])


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 
 
 ****************************************
 
 

import platform
import sys

info = 'OS info is \n{}\n\nPython version is {} {}'.format(
    platform.uname(),
    sys.version,
    platform.architecture(),
)
print(info)

with open('os_info.txt', 'w', encoding='utf8') as file:
    file.write(info)

 
 ****************************************
 
 print("Введите первую точку")
x1 = float(input('X: '))
y1 = float(input('Y: '))
print("\nВведите вторую точку")
x2 = float(input('X: '))
y2 = float(input('Y: '))

if (x1 == x2) or ((x1 == x2) and (y1 == y2)):
    print('Указанные координаты точек прямой не позволяют составить уравнение.')
else:
    x_diff = x1 - x2
    y_diff = y1 - y2
    if y_diff == 0:
        k = abs(y_diff / x_diff)
    else:
        k = y_diff / x_diff
    b = y2 - k * x2

    print("Уравнение прямой, проходящей через эти точки:")
    print("y = ", k, " * x + ", b)

 
 ****************************************
 
 def calculate_sum_numerals(integer):

    sum_numerals = 0

    while integer != 0:
        last_num = integer % 10
        sum_numerals += last_num
        integer //= 10

    return sum_numerals

def calculate_number_numerals(integer):

    count_numerals = 0

    while integer != 0:
        last_num = integer % 10
        count_numerals += 1
        integer //= 10

    return count_numerals


number = int(input('Введите число: '))

sum_numerals = calculate_sum_numerals(number)
number_numerals = calculate_number_numerals(number)

print('\nСумма цифр в числе:', sum_numerals)
print('Количество цифр в числе:', number_numerals)
print('Разность суммы и количества цифр:', sum_numerals - number_numerals)



 
 ****************************************
 
 def turn_numerals(number):

    result = ''
    separatrix = '.'
    separatrix_flag = False
    integer_part = ''
    fractional_part = ''

    for symbol in number:
        if symbol == '.':
            separatrix_flag = True
        elif separatrix_flag:
            fractional_part += symbol

        else:
            integer_part += symbol

    integer_part = int(integer_part)
    fractional_part = int(fractional_part)
    reverse_integer_part = ''
    reverse_fractional_part = ''

    while integer_part != 0:
        last_num = integer_part % 10
        reverse_integer_part += str(last_num)
        integer_part //= 10

    while fractional_part != 0:
        last_num = fractional_part % 10
        reverse_fractional_part += str(last_num)
        fractional_part //= 10

    result = reverse_integer_part + separatrix + reverse_fractional_part

    return float(result)


first_number = input('Введите первое число: ')
second_number = input('Введите второе число: ')

reverse_first_number = turn_numerals(first_number)
reverse_second_number = turn_numerals(second_number)

print('\nПервое число наоборот: ', reverse_first_number)
print('Второе число наоборот:', reverse_second_number)
print('Сумма:', reverse_first_number + reverse_second_number)
 
 ****************************************
 
 def calculate_minimum_divisor(natural_number):
    divisor = 2

    while natural_number % divisor != 0:
        divisor += 1

    return divisor

while True:
    number = int(input('Введите число: '))

    if number <= 1:
        print('Ошибка ввода! Число должно быть больше 1.')
    else:
        result = calculate_minimum_divisor(number)
        print('Наименьший делитель, отличный от единицы:', result)
        break

 
 ****************************************
 
 def search_coin(x, y, rad):

    if (-rad <= x <= rad) and (-rad <= x <= rad):
        print('\nМонетка где-то рядом.')
    else:
        print('\nМонетки в области нет.')


print('Введите координаты монетки:')
number_x = float(input('X: '))
number_y = float(input('Y: '))
radius = float(input('Введите радиус: '))

search_coin(number_x, number_y, radius)

 
 ****************************************
 
 def calculate_necessary_years(year1, year2):

    for year in range(year1, year2 + 1):
        count_num = 0
        result = year
        last_num_in_year = year % 10

        while year != 0:
            last_num = year % 10
            if last_num_in_year == last_num:
                count_num += 1
            year //= 10

        if count_num == 3:
            print(result)


def check_input(year):

    count_num = 0

    while year != 0:
        year //= 10
        count_num += 1

    return count_num


while True:

    first_year = int(input('Введите первый год: '))
    second_year = int(input('Введите второй год: '))

    check_input_first_y = check_input(first_year)
    check_input_second_y = check_input(second_year)

    if (check_input_first_y < 4) or (check_input_second_y < 4):
        print('Ошибка ввода! Введите, пожалуйста, годы, которые состоят из четырех цифр.')
    elif first_year > second_year:
        print('Ошибка ввода! Введите, пожалуйста, диапозон годов, в котором счет лет идет от меньшего к большему.')
    else:
        print(f'\nГоды от {first_year} до {second_year} с тремя одинаковыми цифрами: ')
        calculate_necessary_years(first_year, second_year)
        break



 
 ****************************************
 
 first_list = [1, 5, 3]
second_list = [1, 5, 1, 5]
third_list = [1, 3, 1, 5, 3, 3]

first_list.extend(second_list)

print('Результат работы программы:')
print('Кол-во цифр 5 при первом объединении:', first_list.count(5))

for _ in range(first_list.count(5)):
    first_list.remove(5)

first_list.extend(third_list)

print('Кол-во цифр 3 при втором объединении:', first_list.count(3))
print('Итоговый список: ', first_list)

 
 ****************************************
 
 def make_ascending_list(total_class):

    for index_minimum_num in range(len(total_class)):
        for current_num in range(index_minimum_num, len(total_class)):
            if total_class[index_minimum_num] >= total_class[current_num]:
                total_class[index_minimum_num], total_class[current_num] =\
                    total_class[current_num], total_class[index_minimum_num]

    return total_class


first_class = list(range(160, 177, 2))
second_class = list(range(162, 181, 3))


first_class.extend(second_class)

result = make_ascending_list(first_class)

print('Отсортированный список учеников:', result)
 
 ****************************************
 
 shop = [['каретка', 1200], ['шатун', 1000], ['седло', 300],
        ['педаль', 100], ['седло', 1500], ['рама', 12000],
        ['обод', 2000], ['шатун', 200], ['седло', 2700]]

name_component = input('Название детали: ')
total_cost = 0
count_components = 0

for i_list in range(len(shop)):
    for i_elem in range(2):
        if shop[i_list][i_elem] == name_component:
            count_components += shop[i_list][i_elem].count(name_component)
            total_cost += shop[i_list][i_elem + 1]

print('Кол-во деталей —', count_components)
print('Общая стоимость —', total_cost)

 
 ****************************************
 
 def is_guest_list(guest, guests_list):
    for elem in guests_list:
        if guest == elem:
            return True

    return False


guests = ['Петя', 'Ваня', 'Саша', 'Лиза', 'Катя']


while True:

    print(f'\nСейчас на вечеринке {len(guests)} человек: {guests}')
    action_guest = input('Гость пришел или ушел? ')
    if action_guest == 'Пора спать':
        print('\nВечеринка закончилась, все легли спать.')
        break
    else:
        name_guest = input('Имя гостя: ')
        if action_guest == 'пришел' and len(guests) < 6:
            print(f'Привет, {name_guest}!')
            guests.append(name_guest)
        elif action_guest == 'пришел' and len(guests) >= 6:
            print(f'Прости, {name_guest}, но мест нет.')
        elif action_guest == 'ушел':
            if is_guest_list(name_guest, guests):
                guests.remove(name_guest)
                print(f'Пока, {name_guest}!')
            else:
                print('Такого гостя на вечеринке нет.')

 
 ****************************************
 
 def is_song_exist(song, songs_list):
    for i_list in range(len(songs_list)):
        for i_elem in range(2):
            if song == songs_list[i_list][i_elem]:
                return True

    return False


def calculate_time_song(song, songs_list):
    count_time_song = 0
    for i_list in range(len(songs_list)):
        for i_elem in range(2):
            if song == songs_list[i_list][i_elem]:
                count_time_song += songs_list[i_list][i_elem + 1]
                return count_time_song

violator_songs = [
    ['World in My Eyes', 4.86],
    ['Sweetest Perfection', 4.43],
    ['Personal Jesus', 4.56],
    ['Halo', 4.9],
    ['Waiting for the Night', 6.07],
    ['Enjoy the Silence', 4.20],
    ['Policy of Truth', 4.76],
    ['Blue Dress', 4.29],
    ['Clean', 5.83]
]


number_songs = int(input('Сколько песен выбрать? '))
count_time_songs = 0
count_iteration = 0

while count_iteration != number_songs:

    for num_song in range(number_songs):
        name_song = input(f'Название {num_song + 1}-й песни: ')
        if is_song_exist(name_song, violator_songs):
            count_time_songs += calculate_time_song(name_song, violator_songs)
            count_iteration += 1
        else:
            print('\nТакой песни нет в списке! Выбор песен надо начать сначала.')
            count_time_songs = 0
            count_iteration = 0
            break

print(f'\nОбщее время звучания песен: {round(count_time_songs, 2)} минуты')

 
 ****************************************
 
 first_list = []
second_list = []

for num in range(3):
    print(f'Введите {num + 1} число для первого списка:', end=' ')
    first_list.append(int(input()))

for num in range(7):
    print(f'Введите {num + 1} число для второго списка:', end=' ')
    second_list.append(int(input()))

print('\nПервый список:', first_list)
print('Второй список:', second_list)

first_list.extend(second_list)


unique_list = first_list.copy()


for elem in first_list:
    while unique_list.count(elem) >= 2:
        unique_list.remove(elem)


print(f'\nНовый список с уникальными элементами: {unique_list}')
 
 ****************************************
 
 number_skates = int(input('Кол-во коньков: '))

skates_list = []

for num in range(number_skates):
    print(f'Размер {num + 1}-й пары:', end=' ')
    skates_list.append(int(input()))

number_people = int(input('\nКол-во людей: '))

people_list = []

for num in range(number_people):
    print(f'Размер ноги {num + 1}-го человека:', end=' ')
    people_list.append(int(input()))

count_people = 0

for man in people_list:
    for skates in skates_list:
        if man == skates:
            count_people += 1
            index = skates_list.index(skates)
            skates_list.remove(skates)
            skates_list.insert(index, 0)
            break
    continue

print('\nНаибольшее кол-во людей, которые могут взять ролики:', count_people)
 
 ****************************************
 
 number_people = int(input('Кол-во человек: '))
number_k = int(input('Какое число в считалке? '))

print(f'Значит, выбывает каждый {number_k}-й человек')

people_list = list(range(1, number_people + 1))
out = 0


for _ in range(number_people - 1):
    print('\nТекущий круг людей', people_list)

    start_count = out % len(people_list)
    out = (start_count + number_k - 1) % len(people_list)

    print('Начало счёта с номера', people_list[start_count])
    print('Выбывает человек под номером', people_list[out])

    people_list.remove(people_list[out])


print('\nОстался человек под номером', *people_list)

 
 ****************************************
 
 
number_friends = int(input('Кол-во друзей: '))

number_bill_debts = int(input('Кол-во долговых расписок: '))

friends_list = []

for _ in range(number_friends):
    friends_list.append(list(range(1)))

for num in range(number_bill_debts):
    print(f'\n{num + 1}-я расписка')

    debtor = int(input('Кому: '))
    lender = int(input('От кого: '))
    money = int(input('Сколько: '))
    friends_list[debtor - 1][0] -= money
    friends_list[lender - 1][0] += money

print('Баланс друзей:')

for i_friend in range(number_friends):
    print(f'{i_friend + 1} :', friends_list[i_friend][0])
 
 ****************************************
 
 
num_numbers = int(input('Кол-во чисел: '))

succession = []
numbers = []
count = 0

for _ in range(num_numbers):
    print('Число:', end=' ')
    succession.append(int(input()))

if succession[num_numbers - 1] != succession[num_numbers - 2]:
    for num in range(1, num_numbers):
        numbers.append(succession[num_numbers - (num + 1)])
        count += 1

else:
    for num in range(2, num_numbers):
        numbers.append(succession[num_numbers - (num + 1)])
        count += 1

print('\nПоследовательность:', succession)
print('Нужно приписать чисел:', count)
print('Сами числа:', numbers)

 
 ****************************************
 
 text = input('Введите текст: ')

vowels_list = [sym for sym in text if sym in 'ауоиэыяюеё']

print('Список гласных букв:', vowels_list)
print('Длина списка:', len(vowels_list))

 
 ****************************************
 
 number = int(input('Введите длину списка: '))

num_list = [1 if i_elem % 2 == 0 else i_elem % 5 for i_elem in range(number)]

print('Результат:', num_list)



 
 ****************************************
 
 import random

first_team = [round(random.uniform(5, 10), 2) for _ in range(20)]
second_team = [round(random.uniform(5, 10), 2) for _ in range(20)]
winners_list = [first_team[i_elem] if first_team[i_elem] > second_team[i_elem] else second_team[i_elem]
                for i_elem in range(20)]

print('Первая команда:', first_team)
print('Вторая команда:', second_team)
print('Победители тура:', winners_list)
 
 ****************************************
 
 alphabet = 'abcdefg'

alphabet_copy = alphabet[:]

print('1:', alphabet_copy)
print('2:', alphabet[::-1])
print('3:', alphabet[::2])
print('4:', alphabet[1::2])
print('5:', alphabet[:1])
print('6:', alphabet[(len(alphabet) - 1):])
print('7:', alphabet[3:4])
print('8:', alphabet[(len(alphabet) - 3):(len(alphabet))])
print('9:', alphabet[3:5])
print('10:', alphabet[4:2:-1])

 
 ****************************************
 
 line = input('Введите строку: ')

first_index = line.index('h')
last_index = line.rindex('h')

print('Развёрнутая последовательность между первым и последним h:', line[last_index - 1:first_index:-1])


 
 ****************************************
 
 import random


def move_zeros(list_c):

    count = 0
    for i_elem in list_c:
        if i_elem != 0:
            list_c[count] = i_elem
            count += 1
    for k_elem in range(count, len(list_c)):
        list_c[k_elem] = 0

    return list_c


number_num = int(input('Количество чисел в списке: '))

origin_list = [random.randint(0, 2) for _ in range(number_num)]

list_copy = origin_list[:]

list_result = [i_elem for i_elem in move_zeros(list_copy) if i_elem > 0]

print('Список до сжатия:', origin_list)
print('Список после сжатия:', list_result)

 
 ****************************************
 
 two_dimensional_list = [[i_elem for i_elem in range(i_list + 1, 10 + i_list, 4)] for i_list in range(4)]
print(two_dimensional_list)



 
 ****************************************
 
 import random

number_sticks = int(input('Количество палок: '))
number_throws = int(input('Количество бросков: '))

result_list = ['I'] * number_sticks

for throw in range(number_throws):
    left_i = random.randint(1, number_sticks)
    right_i = random.randint(left_i, number_sticks)

    print(f'Бросок {throw + 1}. Сбиты палки с номера {left_i} по номер {right_i}.')

    result_list[left_i - 1:right_i] = ['.'] * ((right_i - left_i) + 1)


print('Результат:', *result_list)



 
 ****************************************
 
 nice_list = [[[1, 2, 3], [4, 5, 6], [7, 8, 9]],
             [[10, 11, 12], [13, 14, 15], [16, 17, 18]]]

print([elem for i_list in nice_list for j_list in i_list for elem in j_list])

 
 ****************************************
 
 def code_message(mess, transference, alpha):
    codified_message = ' '

    for sym in mess:
        if sym in alpha:
            index_letter = alpha.index(sym)
            index_code_let = (index_letter + transference) % len(alpha)
            codified_message += alpha[index_code_let]
        elif sym in ' ,.-:;?!':
            codified_message += sym

    return codified_message


message = input('Введите сообщение: ')
shift = int(input('Введите сдвиг: '))

alphabet = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'

print('Зашифрованное сообщение:', code_message(message, shift, alphabet))
 
 ****************************************
 
 menu = input('Введите доступное меню (через ";" без пробела): ').split(';')

result = ', '.join(menu)

print('На данный момент в меню есть:', result)

 
 ****************************************
 
 string = input('Введите строку: ').split()

result = string[0]

for word in string:
    if len(word) > len(result):
        result = word

print('Самое длинное слово:', result)
print('Длина этого слова: ', len(result))

 
 ****************************************
 
 name_file = input('Название файла: ')

flag = False

for symbol in '@№$%^&*()':
    if name_file.startswith(symbol):
        flag = True

if flag:
    print('Ошибка: название начинается на один из специальных символов.')
else:
    if not name_file.endswith('.txt') and not name_file.endswith('.docx'):
        print('Ошибка: неверное расширение файла. Ожидалось .txt или .docx.')
    else:
        print('Файл назван верно.')

 
 ****************************************
 
 string = input('Введите строку: ')

print('Результат:', string.title())

 
 ****************************************
 
 while True:

    password = input('Придумайте пароль: ')

    counter_digit = 0
    counter_capital = 0

    for sym in password:
        if sym.isdigit():
            counter_digit += 1
        elif sym.isupper():
            counter_capital += 1

    if (len(password) >= 8) and (counter_digit >= 3) and (counter_capital >= 1):
        print('Это надёжный пароль!')
        break
    else:
        print('Пароль ненадёжный. Попробуйте ещё раз.')


 
 ****************************************
 
 string = input('Введите строку: ')

compressed_str_list = []
counter = 1

for sym in range(len(string)):
    if string[sym] == string[sym + 1: sym + 2]:
        counter += 1
    else:
        compressed_str_list.append(''.join([string[sym], str(counter)]))
        counter = 1

print('\nЗакодированная строка:', ''.join(compressed_str_list))


 
 ****************************************
 
 while True:

    ip_address = input('Введите IP: ')
    flag = True

    if ip_address.count('.') != 3:
        print('Адрес — это четыре числа, разделённые точками.')
        flag = False
    else:
        for num in ip_address.split('.'):
            if num.startswith('-'):
                print('{} меньше 0.'.format(num))
                flag = False
            elif not num.isdigit():
                print('{} — это не целое число.'.format(num))
                flag = False
            elif int(num) > 255:
                print('{} превышает 255.'.format(num))
                flag = False

    if flag:
        break

print('IP-адрес корректен.')

 
 ****************************************
 
 first_string = input('Первая строка: ')
second_string = input('Вторая строка: ')

temporary_string = ''
shift = 0
flag = False

while shift != (len(second_string) - 1):
    for num in range(1, len(second_string) + 1):
        index_shift_let = num % len(second_string)
        temporary_string += second_string[index_shift_let]

    second_string = temporary_string
    temporary_string = ''
    shift += 1

    if second_string == first_string:
        print('Первая строка получается из второй со сдвигом {}.'.format(shift))
        flag = True
        break

if second_string == first_string and not flag:
    print('Первая строка получается из второй со сдвигом {}'.format(shift))
elif not flag:
    print('Первую строку нельзя получить из второй с помощью циклического сдвига.')










 
 ****************************************
 
 message = input('Сообщение: ')

new_message = []
start = 0

for sym in range(len(message)):
    if not message[sym].isalpha():
        new_word = message[start:sym]
        new_message += ''.join([new_word[::-1], message[sym]])
        start = sym + 1

    elif message[sym].isalpha() and sym == len(message) - 1:
        new_word = message[start:]
        new_message.append(new_word[::-1])

print('Новое сообщение:', ''.join(new_message))

 
 ****************************************
 
 def code_text(string, displacement, alpha):
    displacement %= len(alphabet)
    coded_alphabet = ''.join([alpha[displacement:], alpha[:displacement]])
    return ''.join([coded_alphabet[alpha.find(letter)] if letter in alpha else letter for letter in string])


def shift_symbols_word(word, displacement):
    if displacement != 0:
        return ''.join([word[displacement % len(word):], word[:displacement % len(word)]])
    else:
        return word


text = "vujgvmCfb tj ufscfu ouib z/vhm jdjuFyqm jt fscfuu uibo jdju/jnqm fTjnqm tj scfuuf ibou fy/dpnqm yDpnqmf " \
          "jt cfuufs boui dbufe/dpnqmj uGmb tj fuufsc ouib oftufe/ bstfTq jt uufscf uibo otf/ef uzSfbebcjmj " \
          "vout/dp djbmTqf dbtft (ubsfo djbmtqf hifopv up csfbl ifu t/svmf ipvhiBmu zqsbdujdbmju fbutc uz/qvsj " \
          "Fsspst tipvme wfsof qbtt foumz/tjm omfttV mjdjumzfyq odfe/tjmf Jo fui dfgb pg hvjuz-bncj gvtfsf fui " \
          "ubujpoufnq up ftt/hv Uifsf vmetip fc pof.. boe sbcmzqsfgf zpom pof pvt..pcwj xbz pu pe ju/ Bmuipvhi " \
          "uibu bzx bzn puo cf wjpvtpc bu jstug ttvomf sfzpv( i/Evud xOp tj scfuuf ibou /ofwfs uipvhiBm fsofw jt " \
          "fopgu cfuufs boui iu++sjh x/op gJ ifu nfoubujpojnqmf tj eibs pu mbjo-fyq tju( b bec /jefb Jg fui " \
          "foubujpojnqmfn jt fbtz up bjo-fyqm ju znb cf b hppe jefb/ bnftqbdftO bsf pof ipoljoh sfbuh efbj .. " \
          "fu(tm pe psfn gp tf\"uip"

alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ*+!\",-.'("

deciphered_text_1_list = code_text(text, -1, alphabet).split()

shift = -3
deciphered_text_2_list = []
for symbols in deciphered_text_1_list:
    deciphered_text_2_list.append(shift_symbols_word(symbols, shift))
    if "/" in symbols:
        shift -= 1

print(' '.join(deciphered_text_2_list).replace('/ ', '\n'))



 
 ****************************************
 
 violator_songs = {
    'World in My Eyes': 4.86,
    'Sweetest Perfection': 4.43,
    'Personal Jesus': 4.56,
    'Halo': 4.9,
    'Waiting for the Night': 6.07,
    'Enjoy the Silence': 4.20,
    'Policy of Truth': 4.76,
    'Blue Dress': 4.29,
    'Clean': 5.83
}

number_songs = int(input('Сколько песен выбрать? '))
sum_time_songs = 0


for name in range(1, number_songs + 1):

    while True:

        flag = True

        name_song = input('Название {} песни: '.format(name))
        if violator_songs.get(name_song):
            sum_time_songs += violator_songs.get(name_song)
        else:
            print('Такой песни в плейлисте нет.')
            flag = False

        if flag:
            break

print('Общее время звучания песен: {:.2f} минут'.format(sum_time_songs))
 
 ****************************************
 
 number_countries = int(input('Количество стран: '))

country_cities_dict = dict()

for num_country in range(1, number_countries + 1):
    name_country_cities = input('{} страна: '.format(num_country)).split()
    country_cities_dict[name_country_cities[0]] = ' '.join(name_country_cities[1:])

for num_city in range(1, 4):
    name_city = input('\n{} город: '.format(num_city))
    flag = False
    name_country = None

    for key in country_cities_dict:
        if name_city in country_cities_dict[key]:
            flag = True
            name_country = key
            break

    if flag:
        print('Город {0} расположен в стане {1}.'.format(name_city, name_country))
    else:
        print('По городу {} данных нет.'.format(name_city))


 
 ****************************************
 
 data = {
    "address": "0x544444444444",
    "ETH": {
        "balance": 444,
        "total_in": 444,
        "total_out": 4
    },
    "count_txs": 2,
    "tokens": [
        {
            "fst_token_info": {
                "address": "0x44444",
                "name": "fdf",
                "decimals": 0,
                "symbol": "dsfdsf",
                "total_supply": "3228562189",
                "owner": "0x44444",
                "last_updated": 1519022607901,
                "issuances_count": 0,
                "holders_count": 137528,
                "price": False
            },
            "balance": 5000,
            "totalIn": 0,
            "total_out": 0
        },
        {
            "sec_token_info": {
                "address": "0x44444",
                "name": "ggg",
                "decimals": "2",
                "symbol": "fff",
                "total_supply": "250000000000",
                "owner": "0x44444",
                "last_updated": 1520452201,
                "issuances_count": 0,
                "holders_count": 20707,
                "price": False
            },
            "balance": 500,
            "totalIn": 0,
            "total_out": 0
        }
    ]
}


for key in data:
    print(key, ':', data[key])

data['ETH']['total_diff'] = 100
data['tokens'][0]['fst_token_info']['name'] = 'doge'
data['ETH']['total_out'] = data['tokens'][0].pop('total_out')
data['tokens'][1]['sec_token_info']['total_price'] = data['tokens'][1]['sec_token_info'].pop('price')

 
 ****************************************
 
 goods = {
    'Лампа': '12345',
    'Стол': '23456',
    'Диван': '34567',
    'Стул': '45678',
}

store = {
    '12345': [
        {'quantity': 27, 'price': 42},
    ],
    '23456': [
        {'quantity': 22, 'price': 510},
        {'quantity': 32, 'price': 520},
    ],
    '34567': [
        {'quantity': 2, 'price': 1200},
        {'quantity': 1, 'price': 1150},
    ],
    '45678': [
        {'quantity': 50, 'price': 100},
        {'quantity': 12, 'price': 95},
        {'quantity': 43, 'price': 97},
    ],
}

flag = True
total_cost = 0
cost = 1
items = 0

for key_goods in goods:
    for store_key in store.keys():
        if goods[key_goods] == store_key:
            for nested_dict in store[store_key]:
                for key_nested_dict in nested_dict:
                    if flag:
                        items += nested_dict[key_nested_dict]
                        flag = False
                    cost *= nested_dict[key_nested_dict]
                flag = True
                total_cost += cost
                cost = 1

            print('{name} - {item} штук(и), стоимость {cost} рубля(ей).'.format(
                name=key_goods,
                item=items,
                cost=total_cost,
            ))

            total_cost = 0
            cost = 1
            items = 0






 
 ****************************************
 
 def get_frequency_sym(string):

    sym_dict = dict()

    for sym in string:
        if sym in sym_dict:
            sym_dict[sym] += 1
        else:
            sym_dict[sym] = 1

    return sym_dict


def get_inverted_dict(hist):

    sym_inverted_dict = dict()

    for sym, values in hist.items():
        if values not in sym_inverted_dict:
            sym_inverted_dict[values] = list(sym)
        else:
            sym_inverted_dict[values] += sym

    return sym_inverted_dict


text = input('Введите текст: ')

histogram = get_frequency_sym(text)
inverted_dict = get_inverted_dict(histogram)

print('Оригинальный словарь частот:')
for key in sorted(histogram.keys()):
    print(key, ':', histogram[key])


print('\nИнвертированный словарь частот:')
for key in sorted(inverted_dict.keys()):
    print(key, ':', inverted_dict[key])
 
 ****************************************
 
 number_synonyms = int(input('Введите количество пар слов: '))

synonyms_dict = dict()

for num in range(1, number_synonyms + 1):
    pair_synonyms = input('{} пара (введите через пробел тире пробел): '.format(num)).split(' - ')
    synonyms_dict[pair_synonyms[0]] = ''.join(pair_synonyms[1])

print()

while True:
    word = input('Введите слово: ')
    flag = False

    for key in synonyms_dict:
        if word.lower() in synonyms_dict[key].lower():
            print('Синоним: ', key)
            flag = True
            break
        elif word.lower() == key.lower():
            print('Синоним: ', synonyms_dict[key])
            flag = True
            break
        else:
            print('Такого слова нет в словаре')
            break

    if flag:
        break




 
 ****************************************
 
 number_orders = int(input('Введите количество заказов: '))

orders_dict = dict()

for num in range(1, number_orders + 1):
    order = input('{} заказ: '.format(num))
    order_list = order.split()
    if order_list[0] not in orders_dict:
        orders_dict[order_list[0]] = dict()
    if order_list[1] not in orders_dict[order_list[0]]:
        orders_dict[order_list[0]][order_list[1]] = int(order[(len(order) - 1):])
    else:
        orders_dict[order_list[0]][order_list[1]] += int(order[(len(order) - 1):])

print()

for key in sorted(orders_dict.keys()):
    print('{}:'.format(key))
    for nested_key in sorted(orders_dict[key]):
        print('\t\t{0}: {1}'.format(nested_key, orders_dict[key][nested_key]))




 
 ****************************************
 
 import random

max_num = int(input('Введите максимальное число: '))
guess_number = random.randint(1, max_num)
max_range_number = {num for num in range(1, max_num + 1)}

while True:

    guessed_num_flag = False

    answer = input('Нужное число есть среди вот этих чисел: ').split()
    check_answer = ''.join(answer)
    counter_num = 0
    flag_check = True

    for sym in check_answer:
        if sym in '0123456789':
            counter_num += 1
        else:
            flag_check = False

    if check_answer == 'Помогите!':
        print('Артём мог загадать следующие числа:', *max_range_number)
        break
    elif flag_check and counter_num > 0:

        answer_set = {int(elem) for elem in answer}

        if guess_number in answer_set:
            print('Ответ Артёма: Да\n')
            max_range_number = max_range_number.intersection(answer_set)
            guessed_num_flag = True
        else:
            print('Ответ Артёма: Нет\n')
            max_range_number.difference_update(answer_set)

        if (len(max_range_number) == 1) and guessed_num_flag:
            print('Артём загадал следующее число:', *max_range_number)
            break

    else:
        print('Ошибка ввода: введите либо слово "Помогите!", '
              'либо любое натуральное число от 1 до установленного максимального числа\n')



 
 ****************************************
 
 number_people = int(input('Введите количество человек: '))

pair_people_dict = dict()
result = dict()

for num in range(1, number_people):
    pair_people = input('{} пара: '.format(num)).split()
    pair_people_dict[pair_people[0]] = pair_people[1]

for name_parent in pair_people_dict.values():
    if name_parent not in pair_people_dict:
        result[name_parent] = 0

for name_descendant in pair_people_dict:
    for name_parent in list(result):
        if pair_people_dict[name_descendant] in result:
            if pair_people_dict[name_descendant] == name_parent:
                result[name_descendant] = result[name_parent] + 1

print('\n"Высота" каждого члена семьи:')
for name in sorted(result):
    print(name, result[name])

 
 ****************************************
 
 
def calculate_frequency(text):

    frequency_symbols_dict = dict()

    for sym in text:
        if sym in frequency_symbols_dict:
            frequency_symbols_dict[sym] += 1
        else:
            frequency_symbols_dict[sym] = 1

    return frequency_symbols_dict


def is_palindrome(frequency_sym):

    odd_symbols = set()
    for key_sym in frequency_sym:
        if frequency_sym[key_sym] % 2 != 0:
            odd_symbols.add(key_sym)

    if len(odd_symbols) <= 1:
        return True
    else:
        return False


string = input('Введите строку: ')

frequency_symbols = calculate_frequency(string)

if is_palindrome(frequency_symbols):
    print('Можно сделать палиндромом')
else:
    print('Нельзя сделать палиндромом')
 
 ****************************************
 
 
def get_list_interests_sym_surnames(students_dict):

    list_interests = {
        elem
        for nested_dict in students_dict.values()
        for key, value in nested_dict.items()
        if key == 'interests'
        for elem in value
    }
    sym_surnames = [
        sym
        for nested_dict in students_dict.values()
        for key, value in nested_dict.items()
        if key == 'surname'
        for sym in value
    ]

    return list_interests, sym_surnames


students = {
    1: {
        'name': 'Bob',
        'surname': 'Vazovski',
        'age': 23,
        'interests': ['biology, swimming']
    },
    2: {
        'name': 'Rob',
        'surname': 'Stepanov',
        'age': 24,
        'interests': ['math', 'computer games', 'running']
    },
    3: {
        'name': 'Alexander',
        'surname': 'Krug',
        'age': 22,
        'interests': ['languages', 'health food']
    }
}


counter_notes_interests = 0
counter_notes_surnames = 0
counter_notes_age = 0

for key_dict in students:
    if students.get(key_dict).get('interests'):
        counter_notes_interests += 1

    if students.get(key_dict).get('surname'):
        counter_notes_surnames += 1

    if students.get(key_dict).get('age'):
        counter_notes_age += 1

if counter_notes_age < 3:
    print('Данных по возрастам студентов недостаточно для выведения полного результата')
else:
    print('Список пар "ID студента — возраст":', [
        (id_student, value)
        for id_student, nested_dict in students.items()
        for key, value in nested_dict.items()
        if key == 'age'
    ])

if counter_notes_interests < 3:
    print('Данных по интересам студентов недостаточно для выведения полного результата')
else:
    interests = get_list_interests_sym_surnames(students)[0]
    print('Полный список интересов всех студентов:', interests)

if counter_notes_surnames < 3:
    print('Данных по фамилиям студентов недостаточно для выведения полного результата')
else:
    len_surnames = len(get_list_interests_sym_surnames(students)[1])
    print('Общая длина всех фамилий студентов:', len_surnames)

 
 ****************************************
 
 
def get_crypto(iterating_object):
    return is_prime(iterating_object)


def is_prime(data):

    result = list()

    if isinstance(data, dict):
        data = data.items()

    for index, elem in enumerate(data):
        flag = True
        divisor = 2

        if index > 1:
            while divisor < index:
                if index % divisor == 0:
                    flag = False
                    break
                divisor += 1

            if flag:
                result.append(elem)

    return result


print(get_crypto([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))
print(get_crypto('О Дивный Новый мир!'))

 
 ****************************************
 
 
def cut_tuple(nums, random_elem):

    result = list()

    if nums.count(random_elem) == 0:
        return tuple(result)

    elif nums.count(random_elem) == 1:
        index_first_elem = nums.index(random_elem)
        result = [
            elem
            for index, elem in enumerate(nums)
            if index >= index_first_elem
        ]

        return tuple(result)

    else:
        index_first_elem = nums.index(random_elem)
        index_second_elem = nums.index(random_elem, index_first_elem + 1)

        result = [
            elem
            for index, elem in enumerate(nums)
            if (index >= index_first_elem) and (index <= index_second_elem)
        ]

        return tuple(result)


random_element = int(input('Введите число: '))

print(cut_tuple((1, 2, 3, 4, 5, 6, 7, 8, 2, 2, 9, 10), random_element))
 
 ****************************************
 
 players = {
    ("Ivan", "Volkin"): (10, 5, 13),
    ("Bob", "Robbin"): (7, 5, 14),
    ("Rob", "Bobbin"): (12, 8, 2)
}

result = [key + value for key, value in players.items()]

print(result)

 
 ****************************************
 
 members_families = {
    ('Сидоров', 'Никита'): 35,
    ('Сидорова', 'Алина'): 34,
    ('Сидоров', 'Павел'): 10,
    ('Иванов', 'Петр'): 45,
    ('Иванова', 'Светлана'): 44,
    ('Петров', 'Геннадий'): 41,
    ('Петрова', 'Елена'): 38,
    ('Петров', 'Алексей'): 15
}

surname = input('Введите фамилию: ').title()

for name, age in members_families.items():
    if name[0].startswith(surname) or name[0].startswith(surname[:len(surname) - 1]):
        print(*name, age)

 
 ****************************************
 
 import random

origin_list = [random.randint(0, 10) for _ in range(10)]

print('Оригинальный список:', origin_list)

result_part_one = [
    elem
    for index, elem in enumerate(origin_list)
    if index % 2 == 0
]

result_part_two = [
    elem
    for index, elem in enumerate(origin_list)
    if index % 2 != 0
]

total_result = [(result_part_one[index], result_part_two[index]) for index in range(5)]

print('Новый список:', total_result)

# Как вариант, можно использовать функцию zip и распаковать циклом for:
# result = zip(new_list_part_one, new_list_part_two)
# for pair in result:
#     print(pair)

 
 ****************************************
 
 
def get_sort_tuple(nums):

    flag = True

    for number in nums:
        if isinstance(number, float):
            flag = False

    if not flag:
        return nums
    else:
        nums = list(nums)
        for i_num in range(len(nums)):
            for j_num in range(i_num, len(nums)):
                if nums[i_num] > nums[j_num]:
                    nums[i_num], nums[j_num] = nums[j_num], nums[i_num]

    return tuple(nums)


print(get_sort_tuple((6, 3, -1, 8, 4, 10, -5)))

 
 ****************************************
 
 
def add_contact(phonebook):

    name_contact = tuple(input('Введите имя и фамилию нового контакта (через пробел): ').split())
    if name_contact in phonebook:
        print('Такой человек уже есть в контактах.')
        return phonebook
    else:
        number = int(input('Введите номер телефона: '))
        phonebook[name_contact] = number
        return phonebook


phonebook_dict = dict()


def search_contact(phonebook):

    result = list()

    search_surname = input('Введите фамилию для поиска: ').lower()
    for name_person, number in phonebook.items():
        if search_surname in name_person[1].lower():
            result.append(' '.join([name_person[0], name_person[1], str(number), '\n']))

    if result:
        return ''.join(result)
    else:
        result = 'Такой фамилии в списке контактов нет.'
        return result


while True:

    choice_action = int(input('Введите номер действия:\n'
                              ' 1. Добавит контакт\n'
                              ' 2. Найти человека\n'))

    if choice_action == 1:
        print('Текущий словарь контактов:', add_contact(phonebook_dict))

    elif choice_action == 2:
        print(search_contact(phonebook_dict))




 
 ****************************************
 
 number_notes_protocol = int(input('Сколько записей вносится в протокол? '))

protocol_dict = dict()

print('Записи (результат и имя):')
for num in range(1, number_notes_protocol + 1):
    note = input('{}-я запись: '.format(num)).split()
    if note[1] in protocol_dict.keys():
        for key, value in protocol_dict.items():
            if note[1] == key and int(note[0]) > value[0]:
                protocol_dict[key] = [int(note[0]), num]
    else:
        protocol_dict[note[1]] = [int(note[0]), num]

protocol_list = [(value[0], key, value[1]) for key, value in protocol_dict.items()]

for i_tuple in range(len(protocol_list)):
    for j_elem in range(i_tuple, len(protocol_list)):
        if protocol_list[i_tuple][0] < protocol_list[j_elem][0]:
            protocol_list[i_tuple], protocol_list[j_elem] = protocol_list[j_elem], protocol_list[i_tuple]
        elif protocol_list[i_tuple][0] == protocol_list[j_elem][0]:
            if protocol_list[i_tuple][2] > protocol_list[j_elem][2]:
                protocol_list[i_tuple], protocol_list[j_elem] = protocol_list[j_elem], protocol_list[i_tuple]

print('\nИтоги соревнований:')
for num in range(3):
    print('{0}-е место. {1} ({2})'.format((num + 1), protocol_list[num][1], protocol_list[num][0]))





 
 ****************************************
 
 
def check_type_data(data):

    if isinstance(data, dict):
        return list(data)
    elif isinstance(data, set):
        return list(data)
    else:
        return data


def get_zip_objects(text, numbers):

    zip_object = None

    if (len(text) == len(numbers)) or (len(text) < len(numbers)):
        zip_object = [(text[index], numbers[index]) for index in range(len(text))]
    else:
        zip_object = [(text[index], numbers[index]) for index in range(len(numbers))]

    return zip_object


string = input('Строка: ')
tuple_numbers = (10, 20, 30, 40)


checked_type_data = check_type_data(string)
result = get_zip_objects(checked_type_data, tuple_numbers)

generator = (pair for pair in result)

print('Кортеж чисел:', tuple_numbers)
print('\nРезультат:')
print(generator)
for pair in result:
    print(pair)

 
 ****************************************
 
 
def counter_num(num):
    if num == 0:
        return 0
    result = 1 + counter_num(num - 1)
    print(result)
    return result


number = int(input('Введите num: '))

counter_num(number)
 
 ****************************************
 
 
def get_my_zip(data_first, data_second, data_third):

    result = [(data_first[index],
               data_second[index],
               data_third[index])
              for index in range(min(len(data_first), len(data_second), len(data_second)))
              ]

    return result


data_1 = [1, 2, 3, 4, 5]
data_2 = {1: "s", 2: "q", 3: 4}
data_3 = (1, 2, 3, 4, 5)

print(get_my_zip(list(data_1), list(data_2), list(data_3)))


 
 ****************************************
 
 
def search_fibonacci_num(num_pos):
    if num_pos < 2:
        return num_pos
    else:
        return search_fibonacci_num(num_pos - 1) + search_fibonacci_num(num_pos - 2)


num_position = int(input('Введите позицию числа в ряде Фибоначчи: '))

print('Число:', search_fibonacci_num(num_position))
 
 ****************************************
 
 
def search_element(key, dictionary, depth=None):

    if depth is None:
        if key in dictionary:
            return dictionary[key]
    else:
        if key in dictionary and depth > 0:
            return dictionary[key]

    for nested_dict in dictionary.values():
        if isinstance(nested_dict, dict):
            if depth is None:
                result = search_element(key, nested_dict, depth)
            else:
                result = search_element(key, nested_dict, depth - 1)

            if result:
                break
    else:
        result = None

    return result


site = {
    'html': {
        'head': {
            'title': 'Мой сайт'
        },
        'body': {
            'h2': 'Здесь будет мой заголовок',
            'div': 'Тут, наверное, какой-то блок',
            'p': 'А вот здесь новый абзац'
        }
    }
}


required_key = input('Введите искомый ключ: ')
request_of_max_depth = input('Хотите ввести максимальную глубину? Y/N: ').lower()

if request_of_max_depth == 'n':
    print('Значение ключа:', search_element(required_key, site))

elif request_of_max_depth == 'y':
    max_depth = int(input('Введите максимальную глубину: '))
    print('Значение ключа:', search_element(required_key, site, max_depth))

 
 ****************************************
 
 def calculate_math_func(data, saved_factorial_dict={1: 1}):

    if data in saved_factorial_dict:
        result = saved_factorial_dict[data]

    else:
        start = max(saved_factorial_dict.keys()) + 1
        result = max(saved_factorial_dict.values())
        for index in range(start, data + 1):
            result *= index
            saved_factorial_dict[index] = result

    result /= data ** 3
    result = result ** 10

    return result


print(calculate_math_func(10))
print(calculate_math_func(5))
print(calculate_math_func(12))
 
 ****************************************
 
 import copy


def develop_website(product, site_copy):

    for key, value in site_copy.items():
        if 'телефон' in value:
            site_copy[key] = str(value).replace('телефон', product)
        elif 'iPhone' in value:
            site_copy[key] = str(value).replace('iPhone', product)
            result = True
            return result

    for section_site in site_copy.values():
        if isinstance(section_site, dict):
            result = develop_website(product, section_site)
            if result:
                break
    else:
        result = None

    if result:
        return site_copy
    else:
        return result


def display_sites(sites_dict):

    for name_p, new_site in sites_dict.items():
        print('Сайт для {}:'.format(name_p))
        print('site = {')
        for j_key, j_value in new_site.items():
            print(f'\t\t\'{j_key}\':', '{')
            for k_key, k_value in j_value.items():
                if k_key == 'body':
                    break
                print(f'\t\t\t\t\'{k_key}\':', '{')
                for l_key in k_value:
                    print(f'\t\t\t\t\t\t\'{l_key}\':', f'\'{k_value[l_key]}\'', '\n\t\t\t },')

        for j_key, j_value in new_site.items():
            for k_key, k_value in j_value.items():
                if k_key == 'body':
                    print(f'\t\t\t\t\'{k_key}\':', '{')
                    for l_key in k_value:
                        print(f'\t\t\t\t\t\t\'{l_key}\':', f'\'{k_value[l_key]}\',')

        print('\t\t\t\t}')
        print('\t\t}')
        print('}\n')


site = {
    'html': {
        'head': {
            'title': 'Куплю/продам телефон недорого'
        },
        'body': {
            'h2': 'У нас самая низкая цена на iPhone',
            'div': 'Купить',
            'p': 'продать'
        }
    }
}


number_websites = int(input('Сколько сайтов: '))
websites_dict = dict()


for _ in range(number_websites):
    name_product = input('Введите название продукта для нового сайта: ')

    website_copy = copy.deepcopy(site)
    new_website = develop_website(name_product, website_copy)
    websites_dict[name_product] = new_website

    display_sites(websites_dict)





 
 ****************************************
 
 
def calculate_sum(*nums):

    sum_nums = 0

    for i_elem in nums:

        if not isinstance(i_elem, list):
            sum_nums = sum_nums + i_elem
        else:
            sum_nums = sum_nums + calculate_sum(*i_elem)

    return sum_nums


print('Ответ:', calculate_sum([[1, 2, [3]], [1], 3]))
# print('Ответ:', calculate_sum(1, 2, 3, 4, 5))
 
 ****************************************
 
 def unpack_list(nice_l, result=[]):

    for i_elem in nice_l:
        if not isinstance(i_elem, list):
            result.append(i_elem)
        else:
            unpack_list(i_elem, result)

    return result


nice_list = [1, 2, [3, 4], [[5, 6, 7], [8, 9, 10]],
             [[11, 12, 13], [14, 15], [16, 17, 18]]]

print('Ответ:', unpack_list(nice_list))



 
 ****************************************
 
 def move(n, x, y):
    if n == 1:
        print('Переложить диск {0} со стержня номер {1} на стержень номер {2}'.format(n, x, y))
    else:
        number_supporting_rod = 6 - x - y
        move(n - 1, x, number_supporting_rod)
        print('Переложить диск {0} со стержня номер {1} на стержень номер {2}'.format(n, x, y))
        move(n - 1, number_supporting_rod, y)


numbers_disks = int(input('Введите количество дисков: '))
move(numbers_disks, 1, 3)

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем N

    :return: N, например: 14
    :rtype: int
    """

    number_n = int(input('Введите число: '))
    return number_n


def display_result(odd_numbers):
    """
    Выводим список нечётных чисел

    :param odd_numbers: список нечётных чисел, например: [1, 3, 5, 7, 9, 11, 13]
    :type odd_numbers: List[int]
    """
    print(f'\nСписок из нечётных чисел от 1 до N: {odd_numbers}')


def get_odd_numbers(number):
    """
    Получаем отсортированный по возрастанию список
    нечётных чисел от 1 до number.

    :param number: до какого числа нужно рассчитать, например: 14
    :type number: int

    :return: список нечётных чисел, например: [1, 3, 5, 7, 9, 11, 13]
    :rtype: List[int]
    """
    number_list = []
    for num in range(1, number + 1, 2):
        number_list.append(num)

    return number_list


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    number = get_input_parameters()  # получаем параметры
    odd_numbers = get_odd_numbers(number)  # получаем нечётные числа
    display_result(odd_numbers)  # выводим результат
 
 ****************************************
 
 def display_result(participants_names):
    """
    Выводим список имён участников в первый день

    :param participants_names: список имён участников, например: ["Артемий", "Влад", "Дима", "Женя"]
    :type participants_names: List[str]
    """
    print('Первый день:', participants_names)


def get_participants_names(names):
    """
    Получаем элементы списка только с чётными индексами.

    :param names: список имён, например: ["Артемий", "Борис", "Влад", "Гоша", "Дима", "Евгений", "Женя", "Захар"]
    :type names: List[str]

    :return: список имён с чётными индексами , например: ["Артемий", "Влад", "Дима", "Женя"]
    :rtype: List[str]
    """

    names_list_even_i = []
    for index in range(len(names)):
        if index % 2 == 0:
            names_list_even_i.append(names[index])

    return names_list_even_i







if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_participants_names и display_result
    participants_names = get_participants_names(
        ["Артемий", "Борис", "Влад", "Гоша", "Дима", "Евгений", "Женя", "Захар"]
    )  # получаем список имён с чётными индексами
    display_result(participants_names)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем набор клеток

    :return: набор клеток, например: [3, 0, 6, 2, 10]
    :rtype: List[int]
    """
    number_cells = int(input('Кол-во клеток: '))
    cells_list = []

    for num in range(number_cells):
        efficiency_cell = int(input(f'Эффективность {num + 1} клетки: '))
        cells_list.append(efficiency_cell)

    return cells_list


def display_result(cells):
    """
    Выводим список клеток у которых значение меньше индекса

    :param cells: набор клеток, например: [0, 2]
    :type cells: List[int]
    """
    print('\nНеподходящие значения:', end=' ')
    print(*cells, sep=' ')


def select_cells(cells):
    """
    Отбираем список клеток, у которых значение меньше индекса.

    :param cells: набор клеток, например: [3, 0, 6, 2, 10]
    :type cells: List[int]

    :return: набор подходящих клеток, например: [0, 2]
    :rtype: List[int]
    """
    unsuitable_cells = []

    for index, efficiency in enumerate(cells):
        if efficiency < index:
            unsuitable_cells.append(cells[index])

    return unsuitable_cells


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    cells = get_input_parameters()  # получаем параметры
    result_cells = select_cells(cells)  # отбираем клетки
    display_result(result_cells)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем список видеокарт

    :return: набор клеток, например: [3070, 2060, 3090, 3070, 3090]
    :rtype: List[int]
    """
    number_video_cards = int(input('Кол-во видеокарт: '))
    video_cards_list = []

    for num in range(number_video_cards):
        video_cards_model = int(input(f'{num + 1} Видеокарта: '))
        video_cards_list.append(video_cards_model)

    return video_cards_list


def display_result(old_video_cards, new_video_cards):
    """
    Выводим список оставшихся видеокарт

    :param old_video_cards: старый набор видеокарт, например: [3070, 2060, 3090, 3070, 3090]
    :type old_video_cards: List[int]
    :param new_video_cards: новый набор видеокарт, например: [3070, 2060, 3070]
    :type new_video_cards: List[int]
    """
    print('Старый список видеокарт:', end=' ')
    print(*old_video_cards, sep=', ')
    print('Новый список видеокарт:', end=' ')
    print(*new_video_cards, sep=', ')


def select_video_cards(video_cards):
    """
    Удаляем из списка видеокарт наибольшие элементы.

    :param video_cards: набор видеокарт, например: [3070, 2060, 3090, 3070, 3090]
    :type video_cards: List[int]

    :return: набор оставшихся видеокарт, например: [3070, 2060, 3070]
    :rtype: List[int]
    """
    new_video_cards = []
    old_model_video_cards = video_cards[0]

    for model_video_card in video_cards:
        if old_model_video_cards <= model_video_card:
            old_model_video_cards = model_video_card

    for model_v_c in video_cards:
        if model_v_c < old_model_video_cards:
            new_video_cards.append(model_v_c)

    return new_video_cards


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    video_cards = get_input_parameters()  # получаем параметры
    result_video_cards = select_video_cards(video_cards)  # удаляет наибольшие элементы.
    display_result(video_cards, result_video_cards)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем список фильмов, которые пользователь хочет добавить в "любимые"

    :return: добавляемые фильмы, например: ["Леон", "Безумный Макс", "Мементо", "Царь горы"]
    :rtype: List[str]
    """
    number_films = int(input('Сколько фильмов хотите добавить? '))
    films_list = []

    for _ in range(number_films):
        name_film = input('Введите название фильма: ')
        films_list.append(name_film)

    return films_list


def display_result(favorite_films, errors):
    """
    Выводим список ошибок и список любимых фильмов

    :param favorite_films: список любимых фильмов, например: ["Леон", "Мементо"]
    :type favorite_films: List[str]
    :param errors: список ненайденных фильмов, например: ["Безумный Макс", "Царь горы"]
    :type errors: List[str]
    """
    print()
    for film in errors:
        print(f'Ошибка: фильма {film} у нас нет :(')

    print('Ваш список любимых фильмов:', end=' ')
    print(*favorite_films, sep=', ')


def add_favorite_film(new_favorite_films, available_films):
    """
    Добавляем фильмы в список "любимых".

    :param new_favorite_films: фильмы, которые нужно добавить в "любимые",
           например: ["Леон", "Безумный Макс", "Мементо", "Царь горы"]
    :type new_favorite_films: List[str]
    :param available_films: фильмы, которые есть на киносайте,
           например: ["Леон", "Назад в будущее", "Мементо"]
    :type available_films: List[str]

    :return: Список фильмов в списке "любимых" и список не найденных фильмов,
             например: (["Леон", "Мементо"], ["Безумный Макс", "Царь горы"])
    :rtype: Tuple[List[str], List[str]]
    """

    favorite_films_user_list = []
    missing_films_list = []

    for index_favorite_films in range(len(new_favorite_films)):
        count_films = 0
        for index_available_films in range(len(available_films)):
            if new_favorite_films[index_favorite_films] == available_films[index_available_films]:
                count_films += 1

        if count_films == 1:
            favorite_films_user_list.append(new_favorite_films[index_favorite_films])
        else:
            missing_films_list.append(new_favorite_films[index_favorite_films])

    return favorite_films_user_list, missing_films_list


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    available_films = [
        "Крепкий орешек", "Назад в будущее", "Таксист",
        "Леон", "Богемская рапсодия", "Город грехов",
        "Мементо", "Отступники", "Деревня"
    ]
    new_favorite_films = get_input_parameters()  # получаем параметры
    favorite_films, errors = add_favorite_film(
        new_favorite_films,
        available_films
    )  # добавлем фильмы в список "любимых".
    display_result(favorite_films, errors)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем входное слово

    :return: входное слово, например: "привет"
    :rtype: str
    """

    word = input('Введите слово: ')

    return word


def display_result(number_unique_letters):
    """
    Выводим количество уникальных букв в слове

    :param number_unique_letters: количество уникальных букв в слове, например: 6
    :type number_unique_letters: int
    """
    print('Кол-во уникальных букв:', number_unique_letters)


def count_number_unique_letters(word):
    """
    Считаем количество уникальных букв в слове.

    :param word: входное слово, например: "привет"
    :type word: str

    :return: количество уникальных букв в слове, например: 6
    :rtype: int
    """
    letter_list = list(word)
    count_unique_letter = 0

    for symbol in letter_list:
        count_letter = 0
        for index in range(len(letter_list)):
            if symbol == letter_list[index]:
                count_letter += 1

        if count_letter == 1:
            count_unique_letter += 1

    return count_unique_letter


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    word = get_input_parameters()  # получаем параметры
    number_unique_letters = count_number_unique_letters(word)  # считаем количество уникальных букв.
    display_result(number_unique_letters)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем список весов контейнеров и вес нового контейнера
    Незабываем проверит данные: все числа целые и не превышают 200.

    :return: список весов контейнеров и вес нового контейнера,
             например: ([165, 163, 160, 160, 157, 157, 155, 154], 162)
    :rtype: Tuple[List[int], int]
    """
    number_containers = int(input('Кол-во контейнеров: '))
    count_right_containers = 0

    while True:
        weight_containers = int(input('Введите вес контейнера: '))
        if (weight_containers <= 0) or (weight_containers > 200):
            print('\nОшибка ввода: масса контейнеров не должна быть меньше или равна 0'
                  ' либо превышать 200 килограмм. \n')
        else:
            containers_list = [weight_containers]
            break

    while (count_right_containers + 1) != number_containers:
        weight_containers = int(input('Введите вес контейнера: '))
        if (weight_containers > containers_list[count_right_containers]) or \
                (weight_containers <= 0) or (weight_containers > 200):
            print('\nОшибка ввода: последовательность массы контейнеров не должна быть '
                  'возрастающей либо  меньше или равна 0, либо превышать 200 килограмм.\n')
        else:
            containers_list.append(weight_containers)
            count_right_containers += 1

    while True:
        new_container_weight = int(input('Введите вес нового контейнера: '))
        if (new_container_weight <= 0) or (new_container_weight > 200):
            print('\nОшибка ввода: масса контейнеров не должна быть меньше или равна 0'
                  ' либо превышать 200 килограмм. \n')
        else:
            break

    return containers_list, new_container_weight


def display_result(serial_number_new_container):
    """
    Выводим порядковый номер нового контейнера.

    :param serial_number_new_container: порядковый номер нового контейнера, например: 3
    :type serial_number_new_container: int
    """
    print('\nНомер, куда встанет новый контейнер:', serial_number_new_container)


def search_serial_number_new_container(list_container_weights, new_container_weight):
    """
    Ищем куда вставим новый контейнер.

    :param list_container_weights: список весов контейнеров, например: [165, 163, 160, 160, 157, 157, 155, 154]
    :type list_container_weights: List[int]
    :param new_container_weight: вес нового контейнера, например: 166
    :type new_container_weight: int

    :return: порядковый номер нового контейнера, например: 3
    :rtype: int
    """
    number_new_container = 0

    for index in range(len(list_container_weights)):
        if new_container_weight <= list_container_weights[index]:
            number_new_container = index + 2

    return number_new_container


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    list_container_weights, new_container_weight = get_input_parameters()  # получаем параметры
    # Ищем куда вставим новый контейнер.
    serial_number_new_container = search_serial_number_new_container(list_container_weights, new_container_weight)
    display_result(serial_number_new_container)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем сдвиг и начальны список

    :return: например: (3, [1, 4, -3, 0, 10])
    :rtype: Tuple[int, List[int]]
    """
    shift = int(input('Сдвиг: '))
    list_n = [1, 4, -3, 0, 10]
    print('Изначальный список: ', list_n)
    return shift, list_n


def display_result(shifted_list):
    """
    Выводим получившиеся список

    :param shifted_list: сдвинутый список, например: [5, 1, 2, 3, 4]
    :type shifted_list: List[int]
    """
    print('\nСдвинутый список:', shifted_list)


def shift_list(shift, original_list):
    """
    Сдвигаем список на определённое количество элементов в право

    :param shift: сдвиг: 3
    :type shift: int
    :param original_list: Исходный список: [1, 4, -3, 0, 10]
    :type original_list: List[int]

    :return: сдвинутый список, например: [5, 1, 2, 3, 4]
    :rtype: List[int]
    """

    new_list = [0] * len(original_list)
    temporary_i_zero_original_list = original_list[len(original_list) - shift]

    for index in range(len(original_list) - 1, -1, -1):
        new_list[index] = original_list[index - shift]
    new_list[0] = temporary_i_zero_original_list

    return new_list


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    shift, original_list = get_input_parameters()  # получаем параметры
    shifted_list = shift_list(shift, original_list)  # сдвигаем список.
    display_result(shifted_list)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем входное слово

    :return: например: abccba
    :rtype: str
    """
    word = input('Введите слово: ')

    return word


def display_result(is_palindrome):
    """
    Выводим информацию является ли строка палиндромом

    :param is_palindrome: является ли палиндромом, например: True
    :type is_palindrome: bool
    """
    if is_palindrome:
        print('\nСлово является палиндромом.')
    else:
        print('\nСлово не является палиндромом.')


def check_palindrome(word):
    """
    Проверяем является ли слово палиндромом.

    :param word: слово, например: abccba
    :type word: str

    :return: является ли слово палиндром, например: True
    :rtype: bool
    """
    list_word = []
    for symbol in word:
        list_word.append(symbol)

    list_word_inverse = []
    palindrome = False
    for index in range(len(list_word) - 1, -1, -1):
        list_word_inverse.append(list_word[index])

    if list_word == list_word_inverse:
        palindrome = True

    return palindrome


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    word = get_input_parameters()  # получаем параметры
    is_palindrome = check_palindrome(word)  # является ли слово палиндромом.
    display_result(is_palindrome)  # выводим результат

 
 ****************************************
 
 def get_input_parameters():
    """
    Получаем неотсортированный список чисел

    :return: неотсортированный список чисел, например: [1, 4, -3, 0, 10]
    :rtype: List[int]
    """
    original_list = [1, 4, -3, 0, 10]

    return original_list


def display_result(sorted_list):
    """
    Выводим отсортированный список

    :param sorted_list: отсортированный список, например: [-3, 0, 1, 4, 10]
    :type sorted_list: List[int]
    """
    print('Изначальный список: [1, 4, -3, 0, 10]')
    print('Отсортированный список:', sorted_list)


def sort_list(original_list):
    """
    Сортируем список

    :param original_list: Исходный список: [1, 4, -3, 0, 10]
    :type original_list: List[int]

    :return: отсортированный, например: [-3, 0, 1, 4, 10]
    :rtype: List[int]
    """

    for index_minimum_num in range(len(original_list)):
        for current_num in range(index_minimum_num, len(original_list)):
            if original_list[index_minimum_num] > original_list[current_num]:
                original_list[index_minimum_num], original_list[current_num] = original_list[current_num], \
                                                                                  original_list[index_minimum_num]

    return original_list


if __name__ == '__main__':
    # Это условие необходимо, чтобы в рамках автотестов не произошёл
    # вызов функций get_input_parameters и display_result
    original_list = get_input_parameters()  # получаем параметры
    sorted_list = sort_list(original_list)  # сортируем список.
    display_result(sorted_list)  # выводим результат

 
 ****************************************
 
 import unittest

from task_01_list_gen.main import get_odd_numbers


class Test01GetOddNumbers(unittest.TestCase):
    def test_get_odd_numbers_boundary_conditions(self):
        """
        Проверяем граничные условия. При вводе 1 должна получиться последовательность [1]
        """
        odd_numbers = get_odd_numbers(1)
        self.assertEqual(odd_numbers, [1])

    def test_get_odd_numbers(self):
        """
        Проверяем обычный кейс. При вводе 14 должна получиться последовательность [1, 3, 5, 7, 9, 11, 13]
        """

        odd_numbers = get_odd_numbers(14)
        self.assertEqual(odd_numbers, [1, 3, 5, 7, 9, 11, 13])


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_02_tournament.main import get_participants_names


class Test02GetParticipantsNames(unittest.TestCase):
    def test_get_participants_names(self):
        """
        Проверяем обычный кейс. Выводим элементы списка только с чётными индексами.
        """
        participants_names = get_participants_names(["Артемий", "Борис", "Влад", "Гоша"])
        self.assertEqual(participants_names, ["Артемий", "Влад"])


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_03_cells.main import select_cells


class Test03SelectCells(unittest.TestCase):
    def test_select_cells(self):
        """
        Проверяем обычный кейс. При параметрах [5, 3, 0, 6, 2, 10, 4]  должны получить [0 2, 4]
        """
        cells = [3, 0, 6, 2, 10, 4]
        res_cells = select_cells(cells)
        self.assertEqual(res_cells, [0, 2, 4])

    def test_select_cells_no_result(self):
        """
        Проверяем обычный кейс. При параметрах [1, 2, 3]  должны получить []
        """
        cells = [1, 2, 3]
        res_cells = select_cells(cells)
        self.assertEqual(res_cells, [])


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest
from task_04_videocards.main import select_video_cards


class Test04SelectVideoCards(unittest.TestCase):
    def test_select_video_cards(self):
        """
        Проверяем обычный кейс. [3070, 2060, 3090, 3070, 3090]  должны получить [3070, 2060, 3070]
        """
        video_cards_list = [3070, 2060, 3090, 3070, 3090]
        new_video_cards_list = select_video_cards(video_cards_list)

        self.assertEqual(new_video_cards_list, [3070, 2060, 3070])

    def test_select_video_cards_no_result(self):
        """
        Проверяем обычный кейс. [3070, 3070]  должны получить []
        """
        video_cards_list = [3070, 3070]
        new_video_cards_list = select_video_cards(video_cards_list)

        self.assertEqual(new_video_cards_list, [])


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_05_movie.main import add_favorite_film


class Test05AddFavoriteFilm(unittest.TestCase):
    def test_add_favorite_film(self):
        """
        Проверяем обычный кейс. При вводе ["Леон", "Безумный Макс", "Мементо", "Царь горы"]
         должны получить (["Леон", "Мементо"], ["Безумный Макс", "Царь горы"])
        """
        available_films = [
            "Крепкий орешек", "Назад в будущее", "Таксист",
            "Леон", "Богемская рапсодия", "Город грехов",
            "Мементо", "Отступники", "Деревня"
        ]
        new_favorite_films = ["Леон", "Безумный Макс", "Мементо", "Царь горы"]

        favorite_films, errors = add_favorite_film(new_favorite_films,available_films )

        self.assertEqual(set(favorite_films), {"Леон", "Мементо"})
        self.assertEqual(set(errors), {"Безумный Макс", "Царь горы"})


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_06_word_analysis.main import count_number_unique_letters


class Test06CountNumberUniqueLetters(unittest.TestCase):
    def test_main_privet(self):
        """
        Проверяем обычный кейс. При вводе "привет"  должны получить "Кол-во уникальных букв: 6"
        """
        number_unique_letters = count_number_unique_letters("привет")

        self.assertEqual(number_unique_letters, 6)

    def test_main_lava(self):
        """
        Проверяем обычный кейс. При вводе "лава"  должны получить "Кол-во уникальных букв: 2"
        """
        number_unique_letters = count_number_unique_letters("лава")

        self.assertEqual(number_unique_letters, 2)


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_07_containers.main import search_serial_number_new_container


class Test07SearchSerialNumberNewContainer(unittest.TestCase):
    def test_main(self):
        """
        Проверяем обычный кейс. При вводе [165, 163, 160, 160, 157, 157, 155, 154] должны получить 3
        """
        list_container_weights = [165, 163, 160, 160, 157, 157, 155, 154]
        new_container_weight = 162

        serial_number_new_container = search_serial_number_new_container(list_container_weights, new_container_weight)

        self.assertEqual(serial_number_new_container, 3)


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_08_running_nums.main import shift_list


class Test08ShiftList(unittest.TestCase):
    def test_shift_list_1_step(self):
        """
        Проверяем обычный кейс. При вводе 1, [1, 2, 3, 4, 5] должны получить  [5, 1, 2, 3, 4]
        """
        print_result = shift_list(1, [1, 2, 3, 4, 5])
        self.assertEqual(print_result, [5, 1, 2, 3, 4])

    def test_shift_list_3_step(self):
        """
        Проверяем обычный кейс. При вводе 3, [1, 4, -3, 0, 10] должны получить [-3, 0, 10, 1, 4]
        """
        print_result = shift_list(3, [1, 4, -3, 0, 10])
        self.assertEqual(print_result, [-3, 0, 10, 1, 4])


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_09_word_analysis_2.main import check_palindrome


class Test09CheckPalindrome(unittest.TestCase):
    def test_check_palindrome_madam(self):
        """
        Проверяем обычный кейс. При вводе "мадам" True
        """
        is_palindrome = check_palindrome("мадам")
        self.assertEqual(is_palindrome, True)

    def test_check_palindrome_abccba(self):
        """
        Проверяем обычный кейс. При вводе "abccba" должны получить True
        """
        is_palindrome = check_palindrome("abccba")
        self.assertEqual(is_palindrome, True)

    def test_check_palindromen_abbd(self):
        """
        Проверяем обычный кейс. При вводе "abbd" должны получить False
        """
        is_palindrome = check_palindrome("abbd")
        self.assertEqual(is_palindrome, False)


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 import unittest

from task_10_sort.main import sort_list


class Test10Sort(unittest.TestCase):
    def test_sort_list(self):
        """
        Проверяем обычный кейс. При вводе [1, 4, -3, 0, 10] должны получить [-3, 0, 1, 4, 10]
        """
        sorted_list = sort_list([1, 4, -3, 0, 10])
        self.assertEqual(sorted_list, [-3, 0, 1, 4, 10])


if __name__ == '__main__':
    unittest.main()

 
 ****************************************
 
 
 
 ****************************************
 
 

import platform
import sys

info = 'OS info is \n{}\n\nPython version is {} {}'.format(
    platform.uname(),
    sys.version,
    platform.architecture(),
)
print(info)

with open('os_info.txt', 'w', encoding='utf8') as file:
    file.write(info)

 
 ****************************************
 
 print("Введите первую точку")
x1 = float(input('X: '))
y1 = float(input('Y: '))
print("\nВведите вторую точку")
x2 = float(input('X: '))
y2 = float(input('Y: '))

if (x1 == x2) or ((x1 == x2) and (y1 == y2)):
    print('Указанные координаты точек прямой не позволяют составить уравнение.')
else:
    x_diff = x1 - x2
    y_diff = y1 - y2
    if y_diff == 0:
        k = abs(y_diff / x_diff)
    else:
        k = y_diff / x_diff
    b = y2 - k * x2

    print("Уравнение прямой, проходящей через эти точки:")
    print("y = ", k, " * x + ", b)

 
 ****************************************
 
 def calculate_sum_numerals(integer):

    sum_numerals = 0

    while integer != 0:
        last_num = integer % 10
        sum_numerals += last_num
        integer //= 10

    return sum_numerals

def calculate_number_numerals(integer):

    count_numerals = 0

    while integer != 0:
        last_num = integer % 10
        count_numerals += 1
        integer //= 10

    return count_numerals


number = int(input('Введите число: '))

sum_numerals = calculate_sum_numerals(number)
number_numerals = calculate_number_numerals(number)

print('\nСумма цифр в числе:', sum_numerals)
print('Количество цифр в числе:', number_numerals)
print('Разность суммы и количества цифр:', sum_numerals - number_numerals)



 
 ****************************************
 
 def turn_numerals(number):

    result = ''
    separatrix = '.'
    separatrix_flag = False
    integer_part = ''
    fractional_part = ''

    for symbol in number:
        if symbol == '.':
            separatrix_flag = True
        elif separatrix_flag:
            fractional_part += symbol

        else:
            integer_part += symbol

    integer_part = int(integer_part)
    fractional_part = int(fractional_part)
    reverse_integer_part = ''
    reverse_fractional_part = ''

    while integer_part != 0:
        last_num = integer_part % 10
        reverse_integer_part += str(last_num)
        integer_part //= 10

    while fractional_part != 0:
        last_num = fractional_part % 10
        reverse_fractional_part += str(last_num)
        fractional_part //= 10

    result = reverse_integer_part + separatrix + reverse_fractional_part

    return float(result)


first_number = input('Введите первое число: ')
second_number = input('Введите второе число: ')

reverse_first_number = turn_numerals(first_number)
reverse_second_number = turn_numerals(second_number)

print('\nПервое число наоборот: ', reverse_first_number)
print('Второе число наоборот:', reverse_second_number)
print('Сумма:', reverse_first_number + reverse_second_number)
 
 ****************************************
 
 def calculate_minimum_divisor(natural_number):
    divisor = 2

    while natural_number % divisor != 0:
        divisor += 1

    return divisor

while True:
    number = int(input('Введите число: '))

    if number <= 1:
        print('Ошибка ввода! Число должно быть больше 1.')
    else:
        result = calculate_minimum_divisor(number)
        print('Наименьший делитель, отличный от единицы:', result)
        break

 
 ****************************************
 
 def search_coin(x, y, rad):

    if (-rad <= x <= rad) and (-rad <= x <= rad):
        print('\nМонетка где-то рядом.')
    else:
        print('\nМонетки в области нет.')


print('Введите координаты монетки:')
number_x = float(input('X: '))
number_y = float(input('Y: '))
radius = float(input('Введите радиус: '))

search_coin(number_x, number_y, radius)

 
 ****************************************
 
 def calculate_necessary_years(year1, year2):

    for year in range(year1, year2 + 1):
        count_num = 0
        result = year
        last_num_in_year = year % 10

        while year != 0:
            last_num = year % 10
            if last_num_in_year == last_num:
                count_num += 1
            year //= 10

        if count_num == 3:
            print(result)


def check_input(year):

    count_num = 0

    while year != 0:
        year //= 10
        count_num += 1

    return count_num


while True:

    first_year = int(input('Введите первый год: '))
    second_year = int(input('Введите второй год: '))

    check_input_first_y = check_input(first_year)
    check_input_second_y = check_input(second_year)

    if (check_input_first_y < 4) or (check_input_second_y < 4):
        print('Ошибка ввода! Введите, пожалуйста, годы, которые состоят из четырех цифр.')
    elif first_year > second_year:
        print('Ошибка ввода! Введите, пожалуйста, диапозон годов, в котором счет лет идет от меньшего к большему.')
    else:
        print(f'\nГоды от {first_year} до {second_year} с тремя одинаковыми цифрами: ')
        calculate_necessary_years(first_year, second_year)
        break



 
 ****************************************
 
 first_list = [1, 5, 3]
second_list = [1, 5, 1, 5]
third_list = [1, 3, 1, 5, 3, 3]

first_list.extend(second_list)

print('Результат работы программы:')
print('Кол-во цифр 5 при первом объединении:', first_list.count(5))

for _ in range(first_list.count(5)):
    first_list.remove(5)

first_list.extend(third_list)

print('Кол-во цифр 3 при втором объединении:', first_list.count(3))
print('Итоговый список: ', first_list)

 
 ****************************************
 
 def make_ascending_list(total_class):

    for index_minimum_num in range(len(total_class)):
        for current_num in range(index_minimum_num, len(total_class)):
            if total_class[index_minimum_num] >= total_class[current_num]:
                total_class[index_minimum_num], total_class[current_num] =\
                    total_class[current_num], total_class[index_minimum_num]

    return total_class


first_class = list(range(160, 177, 2))
second_class = list(range(162, 181, 3))


first_class.extend(second_class)

result = make_ascending_list(first_class)

print('Отсортированный список учеников:', result)
 
 ****************************************
 
 shop = [['каретка', 1200], ['шатун', 1000], ['седло', 300],
        ['педаль', 100], ['седло', 1500], ['рама', 12000],
        ['обод', 2000], ['шатун', 200], ['седло', 2700]]

name_component = input('Название детали: ')
total_cost = 0
count_components = 0

for i_list in range(len(shop)):
    for i_elem in range(2):
        if shop[i_list][i_elem] == name_component:
            count_components += shop[i_list][i_elem].count(name_component)
            total_cost += shop[i_list][i_elem + 1]

print('Кол-во деталей —', count_components)
print('Общая стоимость —', total_cost)

 
 ****************************************
 
 def is_guest_list(guest, guests_list):
    for elem in guests_list:
        if guest == elem:
            return True

    return False


guests = ['Петя', 'Ваня', 'Саша', 'Лиза', 'Катя']


while True:

    print(f'\nСейчас на вечеринке {len(guests)} человек: {guests}')
    action_guest = input('Гость пришел или ушел? ')
    if action_guest == 'Пора спать':
        print('\nВечеринка закончилась, все легли спать.')
        break
    else:
        name_guest = input('Имя гостя: ')
        if action_guest == 'пришел' and len(guests) < 6:
            print(f'Привет, {name_guest}!')
            guests.append(name_guest)
        elif action_guest == 'пришел' and len(guests) >= 6:
            print(f'Прости, {name_guest}, но мест нет.')
        elif action_guest == 'ушел':
            if is_guest_list(name_guest, guests):
                guests.remove(name_guest)
                print(f'Пока, {name_guest}!')
            else:
                print('Такого гостя на вечеринке нет.')

 
 ****************************************
 
 def is_song_exist(song, songs_list):
    for i_list in range(len(songs_list)):
        for i_elem in range(2):
            if song == songs_list[i_list][i_elem]:
                return True

    return False


def calculate_time_song(song, songs_list):
    count_time_song = 0
    for i_list in range(len(songs_list)):
        for i_elem in range(2):
            if song == songs_list[i_list][i_elem]:
                count_time_song += songs_list[i_list][i_elem + 1]
                return count_time_song

violator_songs = [
    ['World in My Eyes', 4.86],
    ['Sweetest Perfection', 4.43],
    ['Personal Jesus', 4.56],
    ['Halo', 4.9],
    ['Waiting for the Night', 6.07],
    ['Enjoy the Silence', 4.20],
    ['Policy of Truth', 4.76],
    ['Blue Dress', 4.29],
    ['Clean', 5.83]
]


number_songs = int(input('Сколько песен выбрать? '))
count_time_songs = 0
count_iteration = 0

while count_iteration != number_songs:

    for num_song in range(number_songs):
        name_song = input(f'Название {num_song + 1}-й песни: ')
        if is_song_exist(name_song, violator_songs):
            count_time_songs += calculate_time_song(name_song, violator_songs)
            count_iteration += 1
        else:
            print('\nТакой песни нет в списке! Выбор песен надо начать сначала.')
            count_time_songs = 0
            count_iteration = 0
            break

print(f'\nОбщее время звучания песен: {round(count_time_songs, 2)} минуты')

 
 ****************************************
 
 first_list = []
second_list = []

for num in range(3):
    print(f'Введите {num + 1} число для первого списка:', end=' ')
    first_list.append(int(input()))

for num in range(7):
    print(f'Введите {num + 1} число для второго списка:', end=' ')
    second_list.append(int(input()))

print('\nПервый список:', first_list)
print('Второй список:', second_list)

first_list.extend(second_list)


unique_list = first_list.copy()


for elem in first_list:
    while unique_list.count(elem) >= 2:
        unique_list.remove(elem)


print(f'\nНовый список с уникальными элементами: {unique_list}')
 
 ****************************************
 
 number_skates = int(input('Кол-во коньков: '))

skates_list = []

for num in range(number_skates):
    print(f'Размер {num + 1}-й пары:', end=' ')
    skates_list.append(int(input()))

number_people = int(input('\nКол-во людей: '))

people_list = []

for num in range(number_people):
    print(f'Размер ноги {num + 1}-го человека:', end=' ')
    people_list.append(int(input()))

count_people = 0

for man in people_list:
    for skates in skates_list:
        if man == skates:
            count_people += 1
            index = skates_list.index(skates)
            skates_list.remove(skates)
            skates_list.insert(index, 0)
            break
    continue

print('\nНаибольшее кол-во людей, которые могут взять ролики:', count_people)
 
 ****************************************
 
 number_people = int(input('Кол-во человек: '))
number_k = int(input('Какое число в считалке? '))

print(f'Значит, выбывает каждый {number_k}-й человек')

people_list = list(range(1, number_people + 1))
out = 0


for _ in range(number_people - 1):
    print('\nТекущий круг людей', people_list)

    start_count = out % len(people_list)
    out = (start_count + number_k - 1) % len(people_list)

    print('Начало счёта с номера', people_list[start_count])
    print('Выбывает человек под номером', people_list[out])

    people_list.remove(people_list[out])


print('\nОстался человек под номером', *people_list)

 
 ****************************************
 
 
number_friends = int(input('Кол-во друзей: '))

number_bill_debts = int(input('Кол-во долговых расписок: '))

friends_list = []

for _ in range(number_friends):
    friends_list.append(list(range(1)))

for num in range(number_bill_debts):
    print(f'\n{num + 1}-я расписка')

    debtor = int(input('Кому: '))
    lender = int(input('От кого: '))
    money = int(input('Сколько: '))
    friends_list[debtor - 1][0] -= money
    friends_list[lender - 1][0] += money

print('Баланс друзей:')

for i_friend in range(number_friends):
    print(f'{i_friend + 1} :', friends_list[i_friend][0])
 
 ****************************************
 
 
num_numbers = int(input('Кол-во чисел: '))

succession = []
numbers = []
count = 0

for _ in range(num_numbers):
    print('Число:', end=' ')
    succession.append(int(input()))

if succession[num_numbers - 1] != succession[num_numbers - 2]:
    for num in range(1, num_numbers):
        numbers.append(succession[num_numbers - (num + 1)])
        count += 1

else:
    for num in range(2, num_numbers):
        numbers.append(succession[num_numbers - (num + 1)])
        count += 1

print('\nПоследовательность:', succession)
print('Нужно приписать чисел:', count)
print('Сами числа:', numbers)

 
 ****************************************
 
 text = input('Введите текст: ')

vowels_list = [sym for sym in text if sym in 'ауоиэыяюеё']

print('Список гласных букв:', vowels_list)
print('Длина списка:', len(vowels_list))

 
 ****************************************
 
 number = int(input('Введите длину списка: '))

num_list = [1 if i_elem % 2 == 0 else i_elem % 5 for i_elem in range(number)]

print('Результат:', num_list)



 
 ****************************************
 
 import random

first_team = [round(random.uniform(5, 10), 2) for _ in range(20)]
second_team = [round(random.uniform(5, 10), 2) for _ in range(20)]
winners_list = [first_team[i_elem] if first_team[i_elem] > second_team[i_elem] else second_team[i_elem]
                for i_elem in range(20)]

print('Первая команда:', first_team)
print('Вторая команда:', second_team)
print('Победители тура:', winners_list)
 
 ****************************************
 
 alphabet = 'abcdefg'

alphabet_copy = alphabet[:]

print('1:', alphabet_copy)
print('2:', alphabet[::-1])
print('3:', alphabet[::2])
print('4:', alphabet[1::2])
print('5:', alphabet[:1])
print('6:', alphabet[(len(alphabet) - 1):])
print('7:', alphabet[3:4])
print('8:', alphabet[(len(alphabet) - 3):(len(alphabet))])
print('9:', alphabet[3:5])
print('10:', alphabet[4:2:-1])

 
 ****************************************
 
 line = input('Введите строку: ')

first_index = line.index('h')
last_index = line.rindex('h')

print('Развёрнутая последовательность между первым и последним h:', line[last_index - 1:first_index:-1])


 
 ****************************************
 
 import random


def move_zeros(list_c):

    count = 0
    for i_elem in list_c:
        if i_elem != 0:
            list_c[count] = i_elem
            count += 1
    for k_elem in range(count, len(list_c)):
        list_c[k_elem] = 0

    return list_c


number_num = int(input('Количество чисел в списке: '))

origin_list = [random.randint(0, 2) for _ in range(number_num)]

list_copy = origin_list[:]

list_result = [i_elem for i_elem in move_zeros(list_copy) if i_elem > 0]

print('Список до сжатия:', origin_list)
print('Список после сжатия:', list_result)

 
 ****************************************
 
 two_dimensional_list = [[i_elem for i_elem in range(i_list + 1, 10 + i_list, 4)] for i_list in range(4)]
print(two_dimensional_list)



 
 ****************************************
 
 import random

number_sticks = int(input('Количество палок: '))
number_throws = int(input('Количество бросков: '))

result_list = ['I'] * number_sticks

for throw in range(number_throws):
    left_i = random.randint(1, number_sticks)
    right_i = random.randint(left_i, number_sticks)

    print(f'Бросок {throw + 1}. Сбиты палки с номера {left_i} по номер {right_i}.')

    result_list[left_i - 1:right_i] = ['.'] * ((right_i - left_i) + 1)


print('Результат:', *result_list)



 
 ****************************************
 
 nice_list = [[[1, 2, 3], [4, 5, 6], [7, 8, 9]],
             [[10, 11, 12], [13, 14, 15], [16, 17, 18]]]

print([elem for i_list in nice_list for j_list in i_list for elem in j_list])

 
 ****************************************
 
 def code_message(mess, transference, alpha):
    codified_message = ' '

    for sym in mess:
        if sym in alpha:
            index_letter = alpha.index(sym)
            index_code_let = (index_letter + transference) % len(alpha)
            codified_message += alpha[index_code_let]
        elif sym in ' ,.-:;?!':
            codified_message += sym

    return codified_message


message = input('Введите сообщение: ')
shift = int(input('Введите сдвиг: '))

alphabet = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'

print('Зашифрованное сообщение:', code_message(message, shift, alphabet))
 
 ****************************************
 
 menu = input('Введите доступное меню (через ";" без пробела): ').split(';')

result = ', '.join(menu)

print('На данный момент в меню есть:', result)

 
 ****************************************
 
 string = input('Введите строку: ').split()

result = string[0]

for word in string:
    if len(word) > len(result):
        result = word

print('Самое длинное слово:', result)
print('Длина этого слова: ', len(result))

 
 ****************************************
 
 name_file = input('Название файла: ')

flag = False

for symbol in '@№$%^&*()':
    if name_file.startswith(symbol):
        flag = True

if flag:
    print('Ошибка: название начинается на один из специальных символов.')
else:
    if not name_file.endswith('.txt') and not name_file.endswith('.docx'):
        print('Ошибка: неверное расширение файла. Ожидалось .txt или .docx.')
    else:
        print('Файл назван верно.')

 
 ****************************************
 
 string = input('Введите строку: ')

print('Результат:', string.title())

 
 ****************************************
 
 while True:

    password = input('Придумайте пароль: ')

    counter_digit = 0
    counter_capital = 0

    for sym in password:
        if sym.isdigit():
            counter_digit += 1
        elif sym.isupper():
            counter_capital += 1

    if (len(password) >= 8) and (counter_digit >= 3) and (counter_capital >= 1):
        print('Это надёжный пароль!')
        break
    else:
        print('Пароль ненадёжный. Попробуйте ещё раз.')


 
 ****************************************
 
 string = input('Введите строку: ')

compressed_str_list = []
counter = 1

for sym in range(len(string)):
    if string[sym] == string[sym + 1: sym + 2]:
        counter += 1
    else:
        compressed_str_list.append(''.join([string[sym], str(counter)]))
        counter = 1

print('\nЗакодированная строка:', ''.join(compressed_str_list))


 
 ****************************************
 
 while True:

    ip_address = input('Введите IP: ')
    flag = True

    if ip_address.count('.') != 3:
        print('Адрес — это четыре числа, разделённые точками.')
        flag = False
    else:
        for num in ip_address.split('.'):
            if num.startswith('-'):
                print('{} меньше 0.'.format(num))
                flag = False
            elif not num.isdigit():
                print('{} — это не целое число.'.format(num))
                flag = False
            elif int(num) > 255:
                print('{} превышает 255.'.format(num))
                flag = False

    if flag:
        break

print('IP-адрес корректен.')

 
 ****************************************
 
 first_string = input('Первая строка: ')
second_string = input('Вторая строка: ')

temporary_string = ''
shift = 0
flag = False

while shift != (len(second_string) - 1):
    for num in range(1, len(second_string) + 1):
        index_shift_let = num % len(second_string)
        temporary_string += second_string[index_shift_let]

    second_string = temporary_string
    temporary_string = ''
    shift += 1

    if second_string == first_string:
        print('Первая строка получается из второй со сдвигом {}.'.format(shift))
        flag = True
        break

if second_string == first_string and not flag:
    print('Первая строка получается из второй со сдвигом {}'.format(shift))
elif not flag:
    print('Первую строку нельзя получить из второй с помощью циклического сдвига.')










 
 ****************************************
 
 message = input('Сообщение: ')

new_message = []
start = 0

for sym in range(len(message)):
    if not message[sym].isalpha():
        new_word = message[start:sym]
        new_message += ''.join([new_word[::-1], message[sym]])
        start = sym + 1

    elif message[sym].isalpha() and sym == len(message) - 1:
        new_word = message[start:]
        new_message.append(new_word[::-1])

print('Новое сообщение:', ''.join(new_message))

 
 ****************************************
 
 def code_text(string, displacement, alpha):
    displacement %= len(alphabet)
    coded_alphabet = ''.join([alpha[displacement:], alpha[:displacement]])
    return ''.join([coded_alphabet[alpha.find(letter)] if letter in alpha else letter for letter in string])


def shift_symbols_word(word, displacement):
    if displacement != 0:
        return ''.join([word[displacement % len(word):], word[:displacement % len(word)]])
    else:
        return word


text = "vujgvmCfb tj ufscfu ouib z/vhm jdjuFyqm jt fscfuu uibo jdju/jnqm fTjnqm tj scfuuf ibou fy/dpnqm yDpnqmf " \
          "jt cfuufs boui dbufe/dpnqmj uGmb tj fuufsc ouib oftufe/ bstfTq jt uufscf uibo otf/ef uzSfbebcjmj " \
          "vout/dp djbmTqf dbtft (ubsfo djbmtqf hifopv up csfbl ifu t/svmf ipvhiBmu zqsbdujdbmju fbutc uz/qvsj " \
          "Fsspst tipvme wfsof qbtt foumz/tjm omfttV mjdjumzfyq odfe/tjmf Jo fui dfgb pg hvjuz-bncj gvtfsf fui " \
          "ubujpoufnq up ftt/hv Uifsf vmetip fc pof.. boe sbcmzqsfgf zpom pof pvt..pcwj xbz pu pe ju/ Bmuipvhi " \
          "uibu bzx bzn puo cf wjpvtpc bu jstug ttvomf sfzpv( i/Evud xOp tj scfuuf ibou /ofwfs uipvhiBm fsofw jt " \
          "fopgu cfuufs boui iu++sjh x/op gJ ifu nfoubujpojnqmf tj eibs pu mbjo-fyq tju( b bec /jefb Jg fui " \
          "foubujpojnqmfn jt fbtz up bjo-fyqm ju znb cf b hppe jefb/ bnftqbdftO bsf pof ipoljoh sfbuh efbj .. " \
          "fu(tm pe psfn gp tf\"uip"

alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ*+!\",-.'("

deciphered_text_1_list = code_text(text, -1, alphabet).split()

shift = -3
deciphered_text_2_list = []
for symbols in deciphered_text_1_list:
    deciphered_text_2_list.append(shift_symbols_word(symbols, shift))
    if "/" in symbols:
        shift -= 1

print(' '.join(deciphered_text_2_list).replace('/ ', '\n'))



 
 ****************************************
 
 violator_songs = {
    'World in My Eyes': 4.86,
    'Sweetest Perfection': 4.43,
    'Personal Jesus': 4.56,
    'Halo': 4.9,
    'Waiting for the Night': 6.07,
    'Enjoy the Silence': 4.20,
    'Policy of Truth': 4.76,
    'Blue Dress': 4.29,
    'Clean': 5.83
}

number_songs = int(input('Сколько песен выбрать? '))
sum_time_songs = 0


for name in range(1, number_songs + 1):

    while True:

        flag = True

        name_song = input('Название {} песни: '.format(name))
        if violator_songs.get(name_song):
            sum_time_songs += violator_songs.get(name_song)
        else:
            print('Такой песни в плейлисте нет.')
            flag = False

        if flag:
            break

print('Общее время звучания песен: {:.2f} минут'.format(sum_time_songs))
 
 ****************************************
 
 number_countries = int(input('Количество стран: '))

country_cities_dict = dict()

for num_country in range(1, number_countries + 1):
    name_country_cities = input('{} страна: '.format(num_country)).split()
    country_cities_dict[name_country_cities[0]] = ' '.join(name_country_cities[1:])

for num_city in range(1, 4):
    name_city = input('\n{} город: '.format(num_city))
    flag = False
    name_country = None

    for key in country_cities_dict:
        if name_city in country_cities_dict[key]:
            flag = True
            name_country = key
            break

    if flag:
        print('Город {0} расположен в стане {1}.'.format(name_city, name_country))
    else:
        print('По городу {} данных нет.'.format(name_city))


 
 ****************************************
 
 data = {
    "address": "0x544444444444",
    "ETH": {
        "balance": 444,
        "total_in": 444,
        "total_out": 4
    },
    "count_txs": 2,
    "tokens": [
        {
            "fst_token_info": {
                "address": "0x44444",
                "name": "fdf",
                "decimals": 0,
                "symbol": "dsfdsf",
                "total_supply": "3228562189",
                "owner": "0x44444",
                "last_updated": 1519022607901,
                "issuances_count": 0,
                "holders_count": 137528,
                "price": False
            },
            "balance": 5000,
            "totalIn": 0,
            "total_out": 0
        },
        {
            "sec_token_info": {
                "address": "0x44444",
                "name": "ggg",
                "decimals": "2",
                "symbol": "fff",
                "total_supply": "250000000000",
                "owner": "0x44444",
                "last_updated": 1520452201,
                "issuances_count": 0,
                "holders_count": 20707,
                "price": False
            },
            "balance": 500,
            "totalIn": 0,
            "total_out": 0
        }
    ]
}


for key in data:
    print(key, ':', data[key])

data['ETH']['total_diff'] = 100
data['tokens'][0]['fst_token_info']['name'] = 'doge'
data['ETH']['total_out'] = data['tokens'][0].pop('total_out')
data['tokens'][1]['sec_token_info']['total_price'] = data['tokens'][1]['sec_token_info'].pop('price')

 
 ****************************************
 
 goods = {
    'Лампа': '12345',
    'Стол': '23456',
    'Диван': '34567',
    'Стул': '45678',
}

store = {
    '12345': [
        {'quantity': 27, 'price': 42},
    ],
    '23456': [
        {'quantity': 22, 'price': 510},
        {'quantity': 32, 'price': 520},
    ],
    '34567': [
        {'quantity': 2, 'price': 1200},
        {'quantity': 1, 'price': 1150},
    ],
    '45678': [
        {'quantity': 50, 'price': 100},
        {'quantity': 12, 'price': 95},
        {'quantity': 43, 'price': 97},
    ],
}

flag = True
total_cost = 0
cost = 1
items = 0

for key_goods in goods:
    for store_key in store.keys():
        if goods[key_goods] == store_key:
            for nested_dict in store[store_key]:
                for key_nested_dict in nested_dict:
                    if flag:
                        items += nested_dict[key_nested_dict]
                        flag = False
                    cost *= nested_dict[key_nested_dict]
                flag = True
                total_cost += cost
                cost = 1

            print('{name} - {item} штук(и), стоимость {cost} рубля(ей).'.format(
                name=key_goods,
                item=items,
                cost=total_cost,
            ))

            total_cost = 0
            cost = 1
            items = 0






 
 ****************************************
 
 def get_frequency_sym(string):

    sym_dict = dict()

    for sym in string:
        if sym in sym_dict:
            sym_dict[sym] += 1
        else:
            sym_dict[sym] = 1

    return sym_dict


def get_inverted_dict(hist):

    sym_inverted_dict = dict()

    for sym, values in hist.items():
        if values not in sym_inverted_dict:
            sym_inverted_dict[values] = list(sym)
        else:
            sym_inverted_dict[values] += sym

    return sym_inverted_dict


text = input('Введите текст: ')

histogram = get_frequency_sym(text)
inverted_dict = get_inverted_dict(histogram)

print('Оригинальный словарь частот:')
for key in sorted(histogram.keys()):
    print(key, ':', histogram[key])


print('\nИнвертированный словарь частот:')
for key in sorted(inverted_dict.keys()):
    print(key, ':', inverted_dict[key])
 
 ****************************************
 
 number_synonyms = int(input('Введите количество пар слов: '))

synonyms_dict = dict()

for num in range(1, number_synonyms + 1):
    pair_synonyms = input('{} пара (введите через пробел тире пробел): '.format(num)).split(' - ')
    synonyms_dict[pair_synonyms[0]] = ''.join(pair_synonyms[1])

print()

while True:
    word = input('Введите слово: ')
    flag = False

    for key in synonyms_dict:
        if word.lower() in synonyms_dict[key].lower():
            print('Синоним: ', key)
            flag = True
            break
        elif word.lower() == key.lower():
            print('Синоним: ', synonyms_dict[key])
            flag = True
            break
        else:
            print('Такого слова нет в словаре')
            break

    if flag:
        break




 
 ****************************************
 
 number_orders = int(input('Введите количество заказов: '))

orders_dict = dict()

for num in range(1, number_orders + 1):
    order = input('{} заказ: '.format(num))
    order_list = order.split()
    if order_list[0] not in orders_dict:
        orders_dict[order_list[0]] = dict()
    if order_list[1] not in orders_dict[order_list[0]]:
        orders_dict[order_list[0]][order_list[1]] = int(order[(len(order) - 1):])
    else:
        orders_dict[order_list[0]][order_list[1]] += int(order[(len(order) - 1):])

print()

for key in sorted(orders_dict.keys()):
    print('{}:'.format(key))
    for nested_key in sorted(orders_dict[key]):
        print('\t\t{0}: {1}'.format(nested_key, orders_dict[key][nested_key]))




 
 ****************************************
 
 import random

max_num = int(input('Введите максимальное число: '))
guess_number = random.randint(1, max_num)
max_range_number = {num for num in range(1, max_num + 1)}

while True:

    guessed_num_flag = False

    answer = input('Нужное число есть среди вот этих чисел: ').split()
    check_answer = ''.join(answer)
    counter_num = 0
    flag_check = True

    for sym in check_answer:
        if sym in '0123456789':
            counter_num += 1
        else:
            flag_check = False

    if check_answer == 'Помогите!':
        print('Артём мог загадать следующие числа:', *max_range_number)
        break
    elif flag_check and counter_num > 0:

        answer_set = {int(elem) for elem in answer}

        if guess_number in answer_set:
            print('Ответ Артёма: Да\n')
            max_range_number = max_range_number.intersection(answer_set)
            guessed_num_flag = True
        else:
            print('Ответ Артёма: Нет\n')
            max_range_number.difference_update(answer_set)

        if (len(max_range_number) == 1) and guessed_num_flag:
            print('Артём загадал следующее число:', *max_range_number)
            break

    else:
        print('Ошибка ввода: введите либо слово "Помогите!", '
              'либо любое натуральное число от 1 до установленного максимального числа\n')



 
 ****************************************
 
 number_people = int(input('Введите количество человек: '))

pair_people_dict = dict()
result = dict()

for num in range(1, number_people):
    pair_people = input('{} пара: '.format(num)).split()
    pair_people_dict[pair_people[0]] = pair_people[1]

for name_parent in pair_people_dict.values():
    if name_parent not in pair_people_dict:
        result[name_parent] = 0

for name_descendant in pair_people_dict:
    for name_parent in list(result):
        if pair_people_dict[name_descendant] in result:
            if pair_people_dict[name_descendant] == name_parent:
                result[name_descendant] = result[name_parent] + 1

print('\n"Высота" каждого члена семьи:')
for name in sorted(result):
    print(name, result[name])

 
 ****************************************
 
 
def calculate_frequency(text):

    frequency_symbols_dict = dict()

    for sym in text:
        if sym in frequency_symbols_dict:
            frequency_symbols_dict[sym] += 1
        else:
            frequency_symbols_dict[sym] = 1

    return frequency_symbols_dict


def is_palindrome(frequency_sym):

    odd_symbols = set()
    for key_sym in frequency_sym:
        if frequency_sym[key_sym] % 2 != 0:
            odd_symbols.add(key_sym)

    if len(odd_symbols) <= 1:
        return True
    else:
        return False


string = input('Введите строку: ')

frequency_symbols = calculate_frequency(string)

if is_palindrome(frequency_symbols):
    print('Можно сделать палиндромом')
else:
    print('Нельзя сделать палиндромом')
 
 ****************************************
 
 
def get_list_interests_sym_surnames(students_dict):

    list_interests = {
        elem
        for nested_dict in students_dict.values()
        for key, value in nested_dict.items()
        if key == 'interests'
        for elem in value
    }
    sym_surnames = [
        sym
        for nested_dict in students_dict.values()
        for key, value in nested_dict.items()
        if key == 'surname'
        for sym in value
    ]

    return list_interests, sym_surnames


students = {
    1: {
        'name': 'Bob',
        'surname': 'Vazovski',
        'age': 23,
        'interests': ['biology, swimming']
    },
    2: {
        'name': 'Rob',
        'surname': 'Stepanov',
        'age': 24,
        'interests': ['math', 'computer games', 'running']
    },
    3: {
        'name': 'Alexander',
        'surname': 'Krug',
        'age': 22,
        'interests': ['languages', 'health food']
    }
}


counter_notes_interests = 0
counter_notes_surnames = 0
counter_notes_age = 0

for key_dict in students:
    if students.get(key_dict).get('interests'):
        counter_notes_interests += 1

    if students.get(key_dict).get('surname'):
        counter_notes_surnames += 1

    if students.get(key_dict).get('age'):
        counter_notes_age += 1

if counter_notes_age < 3:
    print('Данных по возрастам студентов недостаточно для выведения полного результата')
else:
    print('Список пар "ID студента — возраст":', [
        (id_student, value)
        for id_student, nested_dict in students.items()
        for key, value in nested_dict.items()
        if key == 'age'
    ])

if counter_notes_interests < 3:
    print('Данных по интересам студентов недостаточно для выведения полного результата')
else:
    interests = get_list_interests_sym_surnames(students)[0]
    print('Полный список интересов всех студентов:', interests)

if counter_notes_surnames < 3:
    print('Данных по фамилиям студентов недостаточно для выведения полного результата')
else:
    len_surnames = len(get_list_interests_sym_surnames(students)[1])
    print('Общая длина всех фамилий студентов:', len_surnames)

 
 ****************************************
 
 
def get_crypto(iterating_object):
    return is_prime(iterating_object)


def is_prime(data):

    result = list()

    if isinstance(data, dict):
        data = data.items()

    for index, elem in enumerate(data):
        flag = True
        divisor = 2

        if index > 1:
            while divisor < index:
                if index % divisor == 0:
                    flag = False
                    break
                divisor += 1

            if flag:
                result.append(elem)

    return result


print(get_crypto([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))
print(get_crypto('О Дивный Новый мир!'))

 
 ****************************************
 
 
def cut_tuple(nums, random_elem):

    result = list()

    if nums.count(random_elem) == 0:
        return tuple(result)

    elif nums.count(random_elem) == 1:
        index_first_elem = nums.index(random_elem)
        result = [
            elem
            for index, elem in enumerate(nums)
            if index >= index_first_elem
        ]

        return tuple(result)

    else:
        index_first_elem = nums.index(random_elem)
        index_second_elem = nums.index(random_elem, index_first_elem + 1)

        result = [
            elem
            for index, elem in enumerate(nums)
            if (index >= index_first_elem) and (index <= index_second_elem)
        ]

        return tuple(result)


random_element = int(input('Введите число: '))

print(cut_tuple((1, 2, 3, 4, 5, 6, 7, 8, 2, 2, 9, 10), random_element))
 
 ****************************************
 
 players = {
    ("Ivan", "Volkin"): (10, 5, 13),
    ("Bob", "Robbin"): (7, 5, 14),
    ("Rob", "Bobbin"): (12, 8, 2)
}

result = [key + value for key, value in players.items()]

print(result)

 
 ****************************************
 
 members_families = {
    ('Сидоров', 'Никита'): 35,
    ('Сидорова', 'Алина'): 34,
    ('Сидоров', 'Павел'): 10,
    ('Иванов', 'Петр'): 45,
    ('Иванова', 'Светлана'): 44,
    ('Петров', 'Геннадий'): 41,
    ('Петрова', 'Елена'): 38,
    ('Петров', 'Алексей'): 15
}

surname = input('Введите фамилию: ').title()

for name, age in members_families.items():
    if name[0].startswith(surname) or name[0].startswith(surname[:len(surname) - 1]):
        print(*name, age)

 
 ****************************************
 
 import random

origin_list = [random.randint(0, 10) for _ in range(10)]

print('Оригинальный список:', origin_list)

result_part_one = [
    elem
    for index, elem in enumerate(origin_list)
    if index % 2 == 0
]

result_part_two = [
    elem
    for index, elem in enumerate(origin_list)
    if index % 2 != 0
]

total_result = [(result_part_one[index], result_part_two[index]) for index in range(5)]

print('Новый список:', total_result)

# Как вариант, можно использовать функцию zip и распаковать циклом for:
# result = zip(new_list_part_one, new_list_part_two)
# for pair in result:
#     print(pair)

 
 ****************************************
 
 
def get_sort_tuple(nums):

    flag = True

    for number in nums:
        if isinstance(number, float):
            flag = False

    if not flag:
        return nums
    else:
        nums = list(nums)
        for i_num in range(len(nums)):
            for j_num in range(i_num, len(nums)):
                if nums[i_num] > nums[j_num]:
                    nums[i_num], nums[j_num] = nums[j_num], nums[i_num]

    return tuple(nums)


print(get_sort_tuple((6, 3, -1, 8, 4, 10, -5)))

 
 ****************************************
 
 
def add_contact(phonebook):

    name_contact = tuple(input('Введите имя и фамилию нового контакта (через пробел): ').split())
    if name_contact in phonebook:
        print('Такой человек уже есть в контактах.')
        return phonebook
    else:
        number = int(input('Введите номер телефона: '))
        phonebook[name_contact] = number
        return phonebook


phonebook_dict = dict()


def search_contact(phonebook):

    result = list()

    search_surname = input('Введите фамилию для поиска: ').lower()
    for name_person, number in phonebook.items():
        if search_surname in name_person[1].lower():
            result.append(' '.join([name_person[0], name_person[1], str(number), '\n']))

    if result:
        return ''.join(result)
    else:
        result = 'Такой фамилии в списке контактов нет.'
        return result


while True:

    choice_action = int(input('Введите номер действия:\n'
                              ' 1. Добавит контакт\n'
                              ' 2. Найти человека\n'))

    if choice_action == 1:
        print('Текущий словарь контактов:', add_contact(phonebook_dict))

    elif choice_action == 2:
        print(search_contact(phonebook_dict))




 
 ****************************************
 
 number_notes_protocol = int(input('Сколько записей вносится в протокол? '))

protocol_dict = dict()

print('Записи (результат и имя):')
for num in range(1, number_notes_protocol + 1):
    note = input('{}-я запись: '.format(num)).split()
    if note[1] in protocol_dict.keys():
        for key, value in protocol_dict.items():
            if note[1] == key and int(note[0]) > value[0]:
                protocol_dict[key] = [int(note[0]), num]
    else:
        protocol_dict[note[1]] = [int(note[0]), num]

protocol_list = [(value[0], key, value[1]) for key, value in protocol_dict.items()]

for i_tuple in range(len(protocol_list)):
    for j_elem in range(i_tuple, len(protocol_list)):
        if protocol_list[i_tuple][0] < protocol_list[j_elem][0]:
            protocol_list[i_tuple], protocol_list[j_elem] = protocol_list[j_elem], protocol_list[i_tuple]
        elif protocol_list[i_tuple][0] == protocol_list[j_elem][0]:
            if protocol_list[i_tuple][2] > protocol_list[j_elem][2]:
                protocol_list[i_tuple], protocol_list[j_elem] = protocol_list[j_elem], protocol_list[i_tuple]

print('\nИтоги соревнований:')
for num in range(3):
    print('{0}-е место. {1} ({2})'.format((num + 1), protocol_list[num][1], protocol_list[num][0]))





 
 ****************************************
 
 
def check_type_data(data):

    if isinstance(data, dict):
        return list(data)
    elif isinstance(data, set):
        return list(data)
    else:
        return data


def get_zip_objects(text, numbers):

    zip_object = None

    if (len(text) == len(numbers)) or (len(text) < len(numbers)):
        zip_object = [(text[index], numbers[index]) for index in range(len(text))]
    else:
        zip_object = [(text[index], numbers[index]) for index in range(len(numbers))]

    return zip_object


string = input('Строка: ')
tuple_numbers = (10, 20, 30, 40)


checked_type_data = check_type_data(string)
result = get_zip_objects(checked_type_data, tuple_numbers)

generator = (pair for pair in result)

print('Кортеж чисел:', tuple_numbers)
print('\nРезультат:')
print(generator)
for pair in result:
    print(pair)

 
 ****************************************
 
 
def counter_num(num):
    if num == 0:
        return 0
    result = 1 + counter_num(num - 1)
    print(result)
    return result


number = int(input('Введите num: '))

counter_num(number)
 
 ****************************************
 
 
def get_my_zip(data_first, data_second, data_third):

    result = [(data_first[index],
               data_second[index],
               data_third[index])
              for index in range(min(len(data_first), len(data_second), len(data_second)))
              ]

    return result


data_1 = [1, 2, 3, 4, 5]
data_2 = {1: "s", 2: "q", 3: 4}
data_3 = (1, 2, 3, 4, 5)

print(get_my_zip(list(data_1), list(data_2), list(data_3)))


 
 ****************************************
 
 
def search_fibonacci_num(num_pos):
    if num_pos < 2:
        return num_pos
    else:
        return search_fibonacci_num(num_pos - 1) + search_fibonacci_num(num_pos - 2)


num_position = int(input('Введите позицию числа в ряде Фибоначчи: '))

print('Число:', search_fibonacci_num(num_position))
 
 ****************************************
 
 
def search_element(key, dictionary, depth=None):

    if depth is None:
        if key in dictionary:
            return dictionary[key]
    else:
        if key in dictionary and depth > 0:
            return dictionary[key]

    for nested_dict in dictionary.values():
        if isinstance(nested_dict, dict):
            if depth is None:
                result = search_element(key, nested_dict, depth)
            else:
                result = search_element(key, nested_dict, depth - 1)

            if result:
                break
    else:
        result = None

    return result


site = {
    'html': {
        'head': {
            'title': 'Мой сайт'
        },
        'body': {
            'h2': 'Здесь будет мой заголовок',
            'div': 'Тут, наверное, какой-то блок',
            'p': 'А вот здесь новый абзац'
        }
    }
}


required_key = input('Введите искомый ключ: ')
request_of_max_depth = input('Хотите ввести максимальную глубину? Y/N: ').lower()

if request_of_max_depth == 'n':
    print('Значение ключа:', search_element(required_key, site))

elif request_of_max_depth == 'y':
    max_depth = int(input('Введите максимальную глубину: '))
    print('Значение ключа:', search_element(required_key, site, max_depth))

 
 ****************************************
 
 def calculate_math_func(data, saved_factorial_dict={1: 1}):

    if data in saved_factorial_dict:
        result = saved_factorial_dict[data]

    else:
        start = max(saved_factorial_dict.keys()) + 1
        result = max(saved_factorial_dict.values())
        for index in range(start, data + 1):
            result *= index
            saved_factorial_dict[index] = result

    result /= data ** 3
    result = result ** 10

    return result


print(calculate_math_func(10))
print(calculate_math_func(5))
print(calculate_math_func(12))
 
 ****************************************
 
 import copy


def develop_website(product, site_copy):

    for key, value in site_copy.items():
        if 'телефон' in value:
            site_copy[key] = str(value).replace('телефон', product)
        elif 'iPhone' in value:
            site_copy[key] = str(value).replace('iPhone', product)
            result = True
            return result

    for section_site in site_copy.values():
        if isinstance(section_site, dict):
            result = develop_website(product, section_site)
            if result:
                break
    else:
        result = None

    if result:
        return site_copy
    else:
        return result


def display_sites(sites_dict):

    for name_p, new_site in sites_dict.items():
        print('Сайт для {}:'.format(name_p))
        print('site = {')
        for j_key, j_value in new_site.items():
            print(f'\t\t\'{j_key}\':', '{')
            for k_key, k_value in j_value.items():
                if k_key == 'body':
                    break
                print(f'\t\t\t\t\'{k_key}\':', '{')
                for l_key in k_value:
                    print(f'\t\t\t\t\t\t\'{l_key}\':', f'\'{k_value[l_key]}\'', '\n\t\t\t },')

        for j_key, j_value in new_site.items():
            for k_key, k_value in j_value.items():
                if k_key == 'body':
                    print(f'\t\t\t\t\'{k_key}\':', '{')
                    for l_key in k_value:
                        print(f'\t\t\t\t\t\t\'{l_key}\':', f'\'{k_value[l_key]}\',')

        print('\t\t\t\t}')
        print('\t\t}')
        print('}\n')


site = {
    'html': {
        'head': {
            'title': 'Куплю/продам телефон недорого'
        },
        'body': {
            'h2': 'У нас самая низкая цена на iPhone',
            'div': 'Купить',
            'p': 'продать'
        }
    }
}


number_websites = int(input('Сколько сайтов: '))
websites_dict = dict()


for _ in range(number_websites):
    name_product = input('Введите название продукта для нового сайта: ')

    website_copy = copy.deepcopy(site)
    new_website = develop_website(name_product, website_copy)
    websites_dict[name_product] = new_website

    display_sites(websites_dict)





 
 ****************************************
 
 
def calculate_sum(*nums):

    sum_nums = 0

    for i_elem in nums:

        if not isinstance(i_elem, list):
            sum_nums = sum_nums + i_elem
        else:
            sum_nums = sum_nums + calculate_sum(*i_elem)

    return sum_nums


print('Ответ:', calculate_sum([[1, 2, [3]], [1], 3]))
# print('Ответ:', calculate_sum(1, 2, 3, 4, 5))
 
 ****************************************
 
 def unpack_list(nice_l, result=[]):

    for i_elem in nice_l:
        if not isinstance(i_elem, list):
            result.append(i_elem)
        else:
            unpack_list(i_elem, result)

    return result


nice_list = [1, 2, [3, 4], [[5, 6, 7], [8, 9, 10]],
             [[11, 12, 13], [14, 15], [16, 17, 18]]]

print('Ответ:', unpack_list(nice_list))



 
 ****************************************
 
 def move(n, x, y):
    if n == 1:
        print('Переложить диск {0} со стержня номер {1} на стержень номер {2}'.format(n, x, y))
    else:
        number_supporting_rod = 6 - x - y
        move(n - 1, x, number_supporting_rod)
        print('Переложить диск {0} со стержня номер {1} на стержень номер {2}'.format(n, x, y))
        move(n - 1, number_supporting_rod, y)


numbers_disks = int(input('Введите количество дисков: '))
move(numbers_disks, 1, 3)

 
 ****************************************
 
 import os
import string


def calculate_sum(file, sym_digit):

    sum_nums = 0
    path = os.path.abspath(file)
    input_file = open(path, 'r')

    for i_str in input_file:
        for sym in i_str:
            if sym in sym_digit:
                sum_nums += int(sym)

    input_file.close()

    return sum_nums


def write_sum_in_file(sum_nums):

    output_file = open('answer.txt', 'w')
    output_file.write(str(sum_nums))

    output_file.close()


digits = string.digits
file_name = 'numbers.txt'

sum_numbers = calculate_sum(file_name, digits)
write_sum_in_file(sum_numbers)





 
 ****************************************
 
 import os


def get_list_strings(strings_lst, file):

    path = os.path.abspath(file)
    input_file = open(path, 'r')

    for i_line in input_file:
        strings_lst.append(i_line)

    input_file.close()


def display_reverse_order_strings(str_list):

    for index in range(len(str_list) - 1, -1, -1):

        if index == len(str_list) - 1:
            print(str_list[index], end='\n' * 2)
        else:
            print(str_list[index])


strings_list = list()
file_name = 'zen.txt'

get_list_strings(strings_list, file_name)
display_reverse_order_strings(strings_list)
 
 ****************************************
 
 import os
import string


def get_list_strings(str_list, file):

    path = os.path.abspath(os.path.join('..', '02_zen_of_python',  file))
    input_file = open(path, 'r')

    for i_line in input_file:
        str_list.append(i_line.lower())

    input_file.close()


def get_number_syms_and_rare_sym(str_list):

    counter_sym = 0
    string_sym = ''

    for i_elem in str_list:
        for sym in i_elem:
            if sym in alphabet:
                counter_sym += 1
                string_sym += sym

    sym_dict = dict()
    rare_sym = ''

    for sym in string_sym:
        if sym in sym_dict:
            sym_dict[sym] += 1
        else:
            sym_dict[sym] = 1
        if string_sym.index(sym) == 0:
            rare_sym = ''.join(sym)

    min_value = sym_dict[rare_sym]

    for key, values in sym_dict.items():
        if min_value > values:
            min_value = values
            rare_sym = key

    return counter_sym, rare_sym


def get_number_words(str_list):

    counter_words = 0

    list_of_list_words = [i_elem.split() for i_elem in str_list]

    for i_list in list_of_list_words:
        counter_words += len(i_list)

    return counter_words


alphabet = string.ascii_lowercase
strings_list = list()

file_name = 'zen.txt'

get_list_strings(strings_list, file_name)
number_sym, rare_symbol = get_number_syms_and_rare_sym(strings_list)
number_words = get_number_words(strings_list)

print('Количество букв в файле: {0}\nКоличество слов в файле: {1}'.format(number_sym, number_words))
print('Количество строк в файле: {0}\nНаиболее редкая буква: {1}'.format(len(strings_list), *rare_symbol))
 
 ****************************************
 
 import os


def get_data_about_directory(current_path, dir_info_dict):

    for i_elem in os.listdir(current_path):
        updated_path = os.path.join(current_path, i_elem)

        if os.path.isfile(updated_path):
            dir_info_dict['counter_files'] += 1
            dir_info_dict['directory_size'] += os.path.getsize(updated_path)
        elif os.path.isdir(updated_path):
            dir_info_dict['counter_sub_dir'] += 1
            get_data_about_directory(updated_path, dir_info_dict)


path = 'E:\Skillbox\My repository\Python_Basic\Module14'  # можно сделать запрос на ввод
                                                          # input('Введите абсолютный путь к каталогу: ')
directory_info_dict = {'directory_size': 0,
                       'counter_sub_dir': 0,
                       'counter_files': 0
                       }

get_data_about_directory(path, directory_info_dict)
print('{0}\nРазмер каталога (в Кб) {1}:'.format(path, directory_info_dict['directory_size'] / 1024))
print('Количество подкаталогов: {0}\nКоличество файлов: {1}'.format(
    directory_info_dict['counter_sub_dir'],
    directory_info_dict['counter_files']))


 
 ****************************************
 
 import os


def make_path_to_file():

    while True:
        print('Куда хотите сохранить документ? Введите последовательность папок (через пробел):')
        dirs_for_path = input().split()
        current_path = os.path.abspath(os.path.sep)

        for i_elem in dirs_for_path:
            current_path = os.path.join(current_path, i_elem)

        if not os.path.exists(current_path):
            print('Указанного пути не существует! Введите существующий путь\n')
        else:
            break

    return current_path


def save_document(text, current_path):

    file_name = input('\nВведите имя файла: ')
    current_path = os.path.join(current_path, file_name)

    if os.path.exists(current_path):
        confirmation_writing = input('Вы действительно хотите перезаписать файл? (да/нет): ')
        if confirmation_writing == 'да':
            output_file = open(file_name, 'w')

            output_file.write(text)
            output_file.close()
            print('Файл успешно перезаписан!')
        else:
            print('Изменения в файл не внесены!')
    else:
        output_file = open(file_name, 'w')

        output_file.write(text)
        output_file.close()
        print('Файл успешно сохранён!')


string = input('Введите строку: ')

path = make_path_to_file()
save_document(string, path)

 
 ****************************************
 
 import os
import string


def read_file(file_name, str_list):

    path = os.path.abspath(file_name)

    original_file = open(path, 'r')

    for i_str in original_file:
        str_list.append(i_str)

    original_file.close()

    return path


def cipher_file(list_str, list_ciphered_str, alpha_lowercase, alpha_uppercase, str_punctuation):

    codified_str = ''
    shift = 0

    for i_elem in list_str:
        shift += 1
        for sym in i_elem:
            if sym in alpha_lowercase:
                index_letter = alpha_lowercase.index(sym)
                index_codified_let = (index_letter + shift) % len(alpha_lowercase)
                codified_str += alpha_lowercase[index_codified_let]
            elif sym in alpha_uppercase:
                index_letter = alpha_uppercase.index(sym)
                index_codified_let = (index_letter + shift) % len(alpha_uppercase)
                codified_str += alpha_uppercase[index_codified_let]
            elif sym in str_punctuation:                # На случай, если в исходном тексте
                codified_str += sym                     # будут знаки препинания.

        list_ciphered_str.append(codified_str)
        codified_str = ''


def write_codified_file(list_ciphered_str):

    codified_file_name = 'cipher_text.txt'
    file_path = os.path.abspath(codified_file_name)

    ciphered_file = open(file_path, 'w')

    for i_str in list_ciphered_str:
        ciphered_file.write(i_str + '\n')

    ciphered_file.close()

    return file_path


def display_result(p_source_file, p_codified_file):
    source_file = open(p_source_file, 'r')
    codified_file = open(p_codified_file, 'r')

    display_source_file = source_file.read()
    display_codified_file = codified_file.read()

    source_file.close()
    codified_file.close()

    print('Содержимое файла txt.txt:\n' + display_source_file)
    print('\nСодержимое файла cipher_text.txt:\n' + display_codified_file)


alphabet_lowercase = string.ascii_lowercase
alphabet_uppercase = string.ascii_uppercase
string_punctuation = string.punctuation

source_file_name = 'text.txt'

list_original_str = list()
list_codified_str = list()

path_source_file = read_file(source_file_name, list_original_str)
cipher_file(list_original_str, list_codified_str, alphabet_lowercase, alphabet_uppercase, string_punctuation)
path_codified_file = write_codified_file(list_codified_str)
display_result(path_source_file, path_codified_file)


 
 ****************************************
 
 import os


def read_file(file, list_result):

    current_path = os.path.abspath(file)
    current_file = open(current_path, 'r')

    for i_str in current_file:
        list_result.append(i_str.split())

    current_file.close()

    points_threshold = int(list_result[0][0])
    del list_result[0]

    return points_threshold, current_path


def get_sorted_participants_second_tour(list_result, list_participants, min_number_points):

    for i_list in list_result:
        if int(i_list[2]) > min_number_points:
            list_participants.append(i_list)

    for index in range(len(list_participants)):
        list_participants[index][1] = list_participants[index][1][0] + '.'

        list_participants[index][0], list_participants[index][1] = \
            list_participants[index][1], list_participants[index][0]

    for index_max_num in range(len(list_participants)):
        for index_current_num in range(index_max_num + 1, len(list_participants)):
            if int(list_participants[index_max_num][2]) < \
                    int(list_participants[index_current_num][2]):
                list_participants[index_max_num], list_participants[index_current_num] = \
                    list_participants[index_current_num], list_participants[index_max_num]

    for index in range(len(list_participants)):
        list_participants[index] = ' '.join(list_participants[index])


def write_second_tour_file(list_participants):

    counter = 0

    name_file = 'second_tour.txt'
    current_path = os.path.abspath(name_file)
    current_file = open(current_path, 'w')

    number_participants = len(list_participants)
    current_file.write(str(number_participants) + '\n')

    for i_list in list_participants:
        counter += 1
        current_file.write(str(counter) + ') ' + i_list + '\n')

    current_file.close()

    return current_path


def display_result(p_input_file, p_output_file):
    input_file = open(p_input_file, 'r')
    output_file = open(p_output_file, 'r')

    display_input_file = input_file.read()
    display_output_file = output_file.read()

    input_file.close()
    output_file.close()

    print('Содержимое файла first_tour.txt: \n' + display_input_file)
    print('\nСодержимое файла second_tour.txt: \n' + display_output_file)


file_name = 'first_tour.txt'
list_result_first_tour = list()
list_participants_second_tour = list()

threshold_points, path_input_file = read_file(file_name, list_result_first_tour)
get_sorted_participants_second_tour(list_result_first_tour, list_participants_second_tour,  threshold_points)
path_output_file = write_second_tour_file(list_participants_second_tour)
display_result(path_input_file, path_output_file)


 
 ****************************************
 
 import os
import string


def get_string_symbols_text_and_path(file, alpha):

    current_path = os.path.abspath(file)
    current_file = open(current_path, 'r')

    str_symbols = ''

    list_string = [i_str.lower() for i_str in current_file]

    current_file.close()

    for i_elem in list_string:
        for sym in i_elem:
            if sym in alpha:
                str_symbols += sym

    return str_symbols, current_path


def get_frequency_syms(str_syms, alpha):

    dict_frequency = dict()

    for sym in str_syms:
        if sym in dict_frequency:
            dict_frequency[sym] += 1
        else:
            dict_frequency[sym] = 1

    for key, value in dict_frequency.items():
        dict_frequency[key] = round(value / len(str_syms), 3)

    list_frequency = [[key, value] for key, value in dict_frequency.items()]

    for index_max_list in range(len(list_frequency)):
        for index_cur_list in range(index_max_list + 1, len(list_frequency)):
            if list_frequency[index_max_list][1] < list_frequency[index_cur_list][1]:
                list_frequency[index_max_list], list_frequency[index_cur_list] =\
                    list_frequency[index_cur_list], list_frequency[index_max_list]
            elif list_frequency[index_max_list][1] == list_frequency[index_cur_list][1]:
                if alpha.index(list_frequency[index_max_list][0]) > alpha.index(list_frequency[index_cur_list][0]):
                    list_frequency[index_max_list], list_frequency[index_cur_list] = \
                        list_frequency[index_cur_list], list_frequency[index_max_list]

    for index in range(len(list_frequency)):
        list_frequency[index][1] = str(list_frequency[index][1])
        list_frequency[index] = ' '.join(list_frequency[index])

    return list_frequency


def write_result(lst):

    current_path = os.path.abspath('analysis.txt')
    current_file = open(current_path, 'w')

    for i_list in lst:
        current_file.write(i_list + '\n')

    current_file.close()

    return current_path


def display_result(p_input_file, p_output_file):
    input_file = open(p_input_file, 'r')
    output_file = open(p_output_file, 'r')

    display_input_file = input_file.read()
    display_output_file = output_file.read()

    input_file.close()
    output_file.close()

    print('Содержимое файла text.txt: \n' + display_input_file)
    print('\nСодержимое файла analysis.txt: \n' + display_output_file)


alphabet = string.ascii_lowercase

file_name = 'text.txt'

string_syms, path_input_file = get_string_symbols_text_and_path(file_name, alphabet)
list_result = get_frequency_syms(string_syms, alphabet)
path_output_file = write_result(list_result)
display_result(path_input_file, path_output_file)

 
 ****************************************
 
 import os
import zipfile
import string


def extract_file(file_zip, file):

    path_zip_file = os.path.abspath(file_zip)

    fantasy_zip = zipfile.ZipFile(path_zip_file)
    fantasy_zip.extract(file)

    fantasy_zip.close()


def read_file_and_get_string_syms(file, roman_alpha, rus_alpha):

    str_symbols = ''

    current_path = os.path.abspath(file)
    current_file = open(current_path, 'r', encoding='utf-8')

    list_str = [i_str for i_str in current_file]

    for i_str in list_str:
        for sym in i_str:
            if sym in roman_alpha:
                str_symbols += sym
            elif sym in rus_alpha:
                str_symbols += sym

    current_file.close()

    return str_symbols


def get_sorted_statistic_sym(str_syms):

    dict_frequency_let = dict()

    for sym in str_syms:
        if sym in dict_frequency_let:
            dict_frequency_let[sym] += 1
        else:
            dict_frequency_let[sym] = 1

    lists_frequency_let = [[key, value] for key, value in dict_frequency_let.items()]

    for index_max_list in range(len(lists_frequency_let)):
        for index_cur_value in range(index_max_list + 1, len(lists_frequency_let)):
            if lists_frequency_let[index_max_list][1] < lists_frequency_let[index_cur_value][1]:
                lists_frequency_let[index_max_list], lists_frequency_let[index_cur_value] = \
                    lists_frequency_let[index_cur_value], lists_frequency_let[index_max_list]

    return lists_frequency_let


def display_result(result):

    print('Статистика встречаемости букв в романе "Война и мир":')

    for i_elem in result:
        print('Буква "{0}" встречается {1} раз(а)'.format(i_elem[0], i_elem[1]))


roman_alphabet = string.ascii_letters
rus_alphabet = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюяАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ'

file_zip_name = 'voyna-i-mir.zip'
file_name = 'voyna-i-mir.txt'

extract_file(file_zip_name, file_name)

string_syms = read_file_and_get_string_syms(file_name, roman_alphabet, rus_alphabet)
result_lists = get_sorted_statistic_sym(string_syms)

display_result(result_lists)





 
 ****************************************
 
 
def get_sum_of_symbols(file):
    sum_of_symbols = 0
    counter_of_lines = -1
    try:
        with open(file, 'r', encoding='utf-8') as input_file:
            for i_line in input_file:
                counter_of_lines += 1
                length = len(i_line)
                try:
                    if i_line.endswith('\n'):
                        length -= 1
                    if length < 3:
                        raise BaseException('Ошибка: менее трёх символов в строке {}.'.format(counter_of_lines))
                except BaseException as exc:
                    print(exc)
                    with open('errors.log', 'w', encoding='utf-8') as file_of_error:
                        file_of_error.write(str(exc))

                sum_of_symbols += length
    except FileNotFoundError:
        print('Ошибка: указанного файла не существует.')
    else:
        return sum_of_symbols


name_of_file = 'people.txt'

sum_of_sym = get_sum_of_symbols(name_of_file)

if sum_of_sym:
    print('Общее количество символов: {}.'.format(sum_of_sym))

 
 ****************************************
 
 import random


def f(x, y):
    x += random.randint(0, 10)
    y += random.randint(0, 5)
    return x / y


def f2(x, y):
    x -= random.randint(0, 10)
    y -= random.randint(0, 5)
    return y / x


try:
    with open('coordinates.txt', 'r') as file:

        for line in file:
            nums_list = line.split()
            res1 = f(int(nums_list[0]), int(nums_list[1]))
            res2 = f2(int(nums_list[0]), int(nums_list[1]))
            number = random.randint(0, 100)
            with open('result.txt', 'a') as file_2:
                my_list = sorted([res1, res2, number])
                file_2.write(''.join(str(my_list)) + '\n')
except FileNotFoundError:
    print("Ошибка: указанного файла не существует.")
except ZeroDivisionError:
    print('Ошибка: во одной из функции произошла попытка деления на ноль.')

 
 ****************************************
 
 import random


def break_out_of_cycle(file, sum_of_num, error):

    try:
        with open(file, 'w') as output_file:
            while sum_of_num < 777:
                num = int(input('Введите число: '))
                sum_of_num += num
                if error == random.randint(1, 13):
                    raise BaseException('Вас постигла неудача!')
                output_file.write(str(num) + '\n')
    except BaseException as exc:
        print(exc)
    else:
        print('Вы успешно выполнили условие для выхода из порочного цикла!')


def display_result(file):

    with open(file, 'r') as output_file:
        display_output_file = output_file.read()
        print('\nСодержимое файла out_file.txt:')
        print(display_output_file)


sum_of_numbers = 0
error_num = 13
name_of_file = 'out_file.txt'

break_out_of_cycle(name_of_file, sum_of_numbers,error_num)
display_result(name_of_file)





 
 ****************************************
 
 

def check_data(file):
    try:
        with open(file, 'r', encoding='utf-8') as input_file:
            for i_line in input_file:
                line = i_line.split()
                try:
                    if len(line) < 3:
                        raise IndexError
                    elif not line[0].isalpha():
                        raise NameError
                    elif '@' not in line[1] and '.' not in line[1]:
                        raise SyntaxError
                    elif 10 > int(line[2]) or int(line[2]) > 99:
                        raise ValueError
                    else:
                        with open('registrations_good.log', 'a', encoding='utf-8') as file_without_errors:
                            file_without_errors.write(i_line)
                except (IndexError, NameError, SyntaxError, ValueError) as exc:
                    with open('registrations_bad.log', 'a', encoding='utf-8') as file_with_errors:
                        if type(exc) == IndexError:
                            str_of_error = put_exception('IndexError')
                        elif type(exc) == NameError:
                            str_of_error = put_exception('NameError')
                        elif type(exc) == SyntaxError:
                            str_of_error = put_exception('SyntaxError')
                        elif type(exc) == ValueError:
                            str_of_error = put_exception('ValueError')
                        file_with_errors.write(i_line[:len(i_line) - 1] + '\t\t\t' + str_of_error + '\n')
    except FileNotFoundError:
        print('Ошибка: указанного файла не существует.')


def put_exception(exception):

    if exception == 'IndexError':
        return 'НЕ присутствуют все три поля'
    elif exception == 'NameError':
        return 'Поле «Имя» содержит НЕ только буквы.'
    elif exception == 'SyntaxError':
        return 'Поле «Имейл» НЕ содержит @ и . (точку).'
    elif exception == 'ValueError':
        return 'Поле «Возраст» НЕ является числом от 10 до 99'


name_of_file = 'registrations.txt'
check_data(name_of_file)

 
 ****************************************
 
 

def calculate_sum_cal_operation(file, sum_of_result):
    try:
        with open(file, 'r') as input_file:
            for i_line in input_file:
                line = i_line.split()
                try:
                    if int(line[2]) == 0 and line[1] in '/%//':
                        raise ZeroDivisionError('Обнаружена ошибка в строке: {}: на ноль делить нельзя.'.format(i_line))
                    if line[1] == '+':
                        sum_of_result += int(line[0]) + int(line[2])
                    elif line[1] == '-':
                        sum_of_result += int(line[0]) - int(line[2])
                    elif line[1] == '*':
                        sum_of_result += int(line[0]) * int(line[2])
                    elif line[1] == '/':
                        sum_of_result += int(line[0]) / int(line[2])
                    elif line[1] == '//':
                        sum_of_result += int(line[0]) // int(line[2])
                    elif line[1] == '%':
                        sum_of_result += int(line[0]) % int(line[2])
                    else:
                        raise SyntaxError('Обнаружена ошибка в строке: {}'.format(i_line))
                except (SyntaxError, ZeroDivisionError) as exc:
                    sum_of_result += correct_mistake(str(exc))
    except FileNotFoundError:
        print('Указанного файла не существует')
    else:
        return sum_of_result


def correct_mistake(exception):

    result_of_expression = None
    print(exception[:len(exception) - 1], end='\t\t')

    while True:

        action_of_user = input('Хотите исправить? ')
        try:
            if action_of_user.lower() == 'да':
                correct_str = input('Введите исправленную строку: ').split()
                if len(correct_str) != 3:
                    raise BaseException('Ошибка ввода строки: введите, пожалуйста, выражение'
                                        ' в формате ОПЕРАНД_1 ОПЕРАЦИЯ ОПЕРАНД_2, разделённые пробелами.')
                if correct_str[1] == '+':
                    result_of_expression = int(correct_str[0]) + int(correct_str[2])
                elif correct_str[1] == '-':
                    result_of_expression = int(correct_str[0]) - int(correct_str[2])
                elif correct_str[1] == '*':
                    result_of_expression = int(correct_str[0]) * int(correct_str[2])
                elif correct_str[1] == '/':
                    result_of_expression = int(correct_str[0]) / int(correct_str[2])
                elif correct_str[1] == '//':
                    result_of_expression = int(correct_str[0]) // int(correct_str[2])
                elif correct_str[1] == '%':
                    result_of_expression = int(correct_str[0]) % int(correct_str[2])

                return result_of_expression
            elif action_of_user.lower() == 'нет':
                return 0
            else:
                print('Ошибка ввода: введите, пожалуйста, слово "да" или "нет".')
        except BaseException as exc:
            print(exc)


name_of_file = 'calc.txt'
sum_of_operations = 0

result = calculate_sum_cal_operation(name_of_file, sum_of_operations)

if result:
    print('\nСумма результатов:', result)

 
 ****************************************
 
 import os

os.startfile('E:/Skillbox/practical_lessons/Python_Basic/Module23/06_chat/user_2.py')  # чат запустится для двух
                                                                                       # пользователей, чтобы сразу
                                                                                       # можно было
                                                                                       #  сымитировать переписку двух
                                                                                       # людей.


def view_chat():
    try:
        with open('file_chat.txt', 'r', encoding='utf-8') as file_chat:
            display_chat = file_chat.read()
            print(display_chat)
    except FileNotFoundError:
        print('В чате пока нет сообщений.')


def send_message(user):

    text_of_message = input('Введите сообщение: ')
    with open('file_chat.txt', 'a', encoding='utf-8') as file_chat:
        file_chat.write('\n{name}: {text}\n'.format(
            name=user,
            text=text_of_message))


user_name = input('Введите свое имя: ')

while True:
    choice_of_action = input('Выберите действие (1 - посмотреть текущий текст чата; 2 - отправить сообщение): ')
    if choice_of_action == '1':
        view_chat()
    elif choice_of_action == '2':
        send_message(user_name)
    else:
        print('\nНекорректный ввод действия: введите '
              '"1" (посмотреть текущий текст чата) или "2" (отправить сообщение).')


 
 ****************************************
 
 def view_chat():
    try:
        with open('file_chat.txt', 'r', encoding='utf-8') as file_chat:
            display_chat = file_chat.read()
            print(display_chat)
    except FileNotFoundError:
        print('В чате пока нет сообщений.')


def send_message(user):

    text_of_message = input('Введите сообщение: ')
    with open('file_chat.txt', 'a', encoding='utf-8') as file_chat:
        file_chat.write('\n{name}: {text}\n'.format(
            name=user,
            text=text_of_message))


user_name = input('Введите свое имя: ')

while True:
    choice_action = input('Выберите действие (1 - посмотреть текущий текст чата; 2 - отправить сообщение): ')
    if choice_action == '1':
        view_chat()
    elif choice_action == '2':
        send_message(user_name)
    else:
        print('\nНекорректный ввод действия: введите '
              '"1" (посмотреть текущий текст чата) или "2" (отправить сообщение).')
 
 ****************************************
 
 import random


class Warrior:
    health = 100
    number_of_first_attack = 1

    def has_attack(self):

        if random.randint(1, 2) == self.number_of_first_attack:
            return True
        else:
            return False


def make_fight(warrior_1, warrior_2):
    while warrior_1.health > 0 and warrior_2.health > 0:

        if warrior_1.has_attack():
            warrior_2.health -= 20
            print('Атаковал 1 юнит, у юнита 2 осталось {} очков здоровья.'.format(warrior_2.health))
        else:
            warrior_1.health -= 20
            print('Атаковал 2 юнит, у юнита 1 осталось {} очков здоровья.'.format(warrior_1.health))

    if warrior_1.health > warrior_2.health:
        print('Победил 1 юнит.')
    else:
        print('Победил 2 юнит.')


first_warrior = Warrior()
second_warrior = Warrior()

make_fight(first_warrior, second_warrior)

 
 ****************************************
 
 class Student:

    def __init__(self, surname_and_name, number_of_group, progress):
        self.surname_and_name = surname_and_name
        self.number_of_group = number_of_group
        self.progress = progress

    def get_info(self):
        print('Фамилия и имя студента: {}\nНомер группы: {}\nУспеваемость: {}'.format(
            self.surname_and_name,
            self.number_of_group,
            ' '.join(self.progress)
        ))

    def get_average_grade(self):
        sum_grades = 0

        for i_grade in self.progress:
            sum_grades += int(i_grade)

        sum_grades /= len(self.progress)

        return sum_grades


def sorted_list_of_students(students_seq):
    for min_average_grade in range(len(students_seq)):
        for cur_average_grade in range(min_average_grade + 1, len(students_seq)):
            if students_seq[min_average_grade].get_average_grade() > students_seq[cur_average_grade].get_average_grade():
                students_seq[min_average_grade], students_seq[cur_average_grade] = \
                    students_seq[cur_average_grade], students_seq[min_average_grade]


def make_a_list_students(students_seq):
    for number in range(1, 11):
        while True:
            try:
                surname_and_name = input('Введите фамилию и имя {} студента: '.format(number))
                number_of_group = int(input('Введите номер учебной группы: '))
                progress = input('Введите баллы успеваемости студента (пять отметок через пробел): ').split()
                for sym in progress:
                    if not sym.isdigit():
                        raise BaseException('Ошибка: успеваемость должна быть представлена числовыми значениями.'
                                            ' Введите данные о студенте еще раз.\n')
                if len(progress) != 5:
                    raise BaseException('Ошибка: нужно ввести пять отметок. Введите данные о студенте еще раз.\n')
                students_seq.append(Student(surname_and_name, number_of_group, progress))
            except ValueError:
                print('Ошибка: номер группы должен быть числовым значением без пробелов.'
                      ' Введите данные о студенте еще раз.\n')
            except BaseException as exc:
                print(exc)
            else:
                break


def display_result(students_seq):
    print('\nСписок студентов: ')
    for index in range(len(students_seq)):
        print('\n{} студент'.format(index + 1))
        students_seq[index].get_info()


students = list()
make_a_list_students(students)
sorted_list_of_students(students)
display_result(students)
 
 ****************************************
 
 import math


class Circle:

    def __init__(self, x=0, y=0, radius=1):
        self.x = x
        self.y = y
        self.radius = radius

    def get_area(self):
        area = math.pi * self.radius ** 2
        return area

    def get_perimeter(self):
        perimeter = 2 * self.radius * math.pi
        return perimeter

    def extend_diameter_of_circle(self, number):
        self.radius = self.radius * number
        return self.radius


def is_intersection(circle_1, circle_2):
    center_distance_of_circles = math.sqrt((circle_2.x - circle_1.x) ** 2 + (circle_2.y - circle_1.y) ** 2)
    if center_distance_of_circles < (circle_1.radius + circle_2.radius):
        return True
    else:
        return False


def use_circle(main_cir, additional_cir):

    while True:
        try:
            print('Круг имеет по умолчанию следующие параметры: центр круга это координаты'
                  ' x = {}, y = {}, радиус = {}'.format(
                main_cir.x,
                main_cir.y,
                main_cir.radius
            ))
            choice_size = input('Хотите изменить параметры круга? (да/нет): ')

            if choice_size == 'да':
                coordinate_x = int(input('Введите x: '))
                coordinate_y = int(input('Введите y: '))
                radius = int(input('Введите радиус: '))
                main_cir = Circle(coordinate_x, coordinate_y, radius)
            elif choice_size != 'да' and choice_size != 'нет':
                raise BaseException('Ошибка ввода: необходимо ввести "да" или "нет".'
                                    'Необходимо начать действия с кругом заново.\n')

            print('\nКруг может выполнять следующие действия:\n'
                  '1. Находить и возвращать свою площадь;\n'
                  '2. Находить и возвращать свой периметр;\n'
                  '3. Увеличиваться в K раз;\n'
                  '4. Определять, пересекается ли он с другой окружность.\n'
                  'Примечание: для выхода из программы нажмите 5.\n')

            action = int(input('Выберите действие с кругом: '))

            if action == 1:
                print('Площадь круга = {}'.format(round(main_cir.get_area(), 2)))

            elif action == 2:
                print('Периметр круга = {}'.format(round(main_cir.get_perimeter(), 2)))

            elif action == 3:
                number_extended = int(input('Во сколько раз увеличить диаметр круга? '))
                print('Теперь диаметр круга = {}'.format(main_cir.extend_diameter_of_circle(number_extended)))

            elif action == 4:
                if is_intersection(main_cir, additional_cir):
                    print('Круг пересекается с другой окружностью, имеющей координаты: х = {}, y = {}, R = {}'.format(
                        additional_cir.x,
                        additional_cir.y,
                        additional_cir.radius
                    ))
                else:
                    print('Круг не пересекается с другой окружностью, имеющей координаты: х = {}, y = {}, R = {}'.format(
                        additional_cir.x,
                        additional_cir.y,
                        additional_cir.radius
                    ))
            elif action == 5:
                print('До свиданья!')
                break
            else:
                print('Такого действия нет.')

        except ValueError:
            print('Ошибка ввода: необходимо вводить числовые значения. Начните действия с кругом заново.\n')
        except BaseException as exc:
            print(exc)


main_circle = Circle()
additional_circle = Circle(2, 2, 2)
use_circle(main_circle, additional_circle)

 
 ****************************************
 
 import random


class Parent:

    def __init__(self, name, age, children_seq):
        self.name_of_parent = name
        self.age_of_parent = age
        self.children = children_seq

    def get_info(self):
        print('Информация о родителе:\nИмя: {}.\nВозраст: {}.\nЕсть дети: {}.\n'.format(
            self.name_of_parent,
            self.age_of_parent,
            ', '.join(self.children)))

    def reassure_child(self):
        print('{} успокоил ребенка\n'.format(self.name_of_parent))
        return True

    def feed_child(self):
        print('{} покормил ребенка\n'.format(self.name_of_parent))
        return True


class Child:
    state_of_calmness = {1: 'спокоен', 2: 'переживает'}
    state_of_hunger = {1: 'сыт', 2: 'голодный'}

    def __init__(self, age, children_seq):

        self.name_of_child = children_seq
        self.age_of_child = age

    def get_age_info(self, name):

        for index, i_name in enumerate(self.name_of_child):
            if name == i_name:
                return self.age_of_child[index]

    def check_state_of_calmness_of_child(self, child_state):

        if random.randint(1, 2) == 1 or child_state:
            print(self.state_of_calmness[1])
            return True

        else:
            print(self.state_of_calmness[2])
            return False

    def check_state_of_hunger_of_child(self, child_state):

        if random.randint(1, 2) == 1 or child_state:
            print(self.state_of_hunger[1])
            return True

        else:
            print(self.state_of_hunger[2])
            return False

 
 ****************************************
 
 import Fathers_and_sons


def check_family(father, kids):

    child_full = False
    child_calm = False

    while True:
        try:
            print('\nВы можете выбрать следующие действия:\n'
                  '1. получить информацию о родителе;\n'
                  '2. проверить состояние ребенка;\n'
                  '3. выход из программы\n')

            user_action = int(input('Какое действие выбираете? '))
            if user_action == 1:
                father.get_info()
            elif user_action == 2:
                choice_child = input('Введите имя ребенка: ')
                if choice_child in kids.name_of_child:
                    print('Состояние {} (возраст - {} лет):'.format(choice_child, children.get_age_info(choice_child)))
                    result_check_calmness = kids.check_state_of_calmness_of_child(child_calm)
                    result_check_hunger = kids.check_state_of_hunger_of_child(child_full)
                    if not result_check_calmness:
                        choice_action = input('Успокоить ребенка? (да/нет) ')
                        if choice_action == 'да':
                            child_calm = father.reassure_child()
                        elif choice_action != 'да' and choice_action != 'нет':
                            print('Ошибка ввода: нужно ввести "да" или "нет".')
                            continue
                    if not result_check_hunger:
                        choice_action = input('Покормить ребенка? (да/нет) ')
                        if choice_action == 'да':
                            child_full = father.feed_child()
                        elif choice_action != 'да' and choice_action != 'нет.':
                            print('Ошибка ввода: нужно ввести "да" или "нет".')
                            continue
                else:
                    print('{} не имеет ребенка с таким именем.'.format(father.name_of_parent))
            elif user_action == 3:
                print('До свидания!')
                break
            elif user_action != 1 and user_action != 2 and user_action != 3:
                print('Ошибка ввода: нужно ввести "1", "2" или "3".')

        except ValueError:
            print('Ошибка ввода: нужно вводить только числовые значения.')


parent = Fathers_and_sons.Parent('Bob', 32, ['Artem', 'Anna', 'Misha'])
children = Fathers_and_sons.Child([10, 8, 7], parent.children)

check_family(parent, children)

 
 ****************************************
 
 import random


class Potato:
    stages = {0: 'Отсутствует', 1: 'Росток', 2: 'Зеленая', 3: 'Зрелая'}

    def __init__(self, index):
        self.index = index
        self.stage = 0

    def grow(self):
        if self.stage < 3:
            self.stage += 1
        self.print_stage()

    def is_ripe(self):
        if self.stage == 3:
            return True
        return False

    def print_stage(self):
        print('Картошка {} сейчас в стадии {}'.format(
            self.index,
            Potato.stages[self.stage]
        ))


class PotatoGarden:

    def __init__(self, count):
        self.potatoes = [Potato(index) for index in range(1, count + 1)]

    def grow_all(self, tend_after):

        if tend_after:
            print('Картошка прорастает!')
            for i_potato in self.potatoes:
                i_potato.grow()
        else:
            print('Так как садовник не ухаживал за картошкой, она не растет.')

    def are_all_ripe(self):
        if not all([i_potato.is_ripe() for i_potato in self.potatoes]):
            return False
        else:
            print('\nВся картошка созрела. Можно собирать!\n')
            return True


class Gardener:
    name = 'Bob'
    potatoes = list()

    def __init__(self, total_crop_of_potatoes=0):
        self.total_crop_of_potatoes = total_crop_of_potatoes

    def tend_after_potatoes(self):

        if random.randint(1, 2) == 1:
            print('Садовник {} поухаживал за грядкой.'.format(self.name))
            return True
        else:
            print('Садовник {} сегодня устал и не стал ухаживать за грядой.'.format(self.name))
            return False

    def crop(self, count):
        self.potatoes = [i_potato for i_potato in range(1, count + 1)]
        self.total_crop_of_potatoes += len(self.potatoes)
        print('Садовник собрал {} картошек.\n '.format(
            len(self.potatoes)
        ))

 
 ****************************************
 
 import Garden


def grow_potatoes(garden, my_gardener):

    while True:
        if garden.are_all_ripe():
            my_gardener.crop(5)
            break
        else:
            print('\nКартошка не созрела!')
            tend_after = gardener.tend_after_potatoes()
            garden.grow_all(tend_after)


my_garden = Garden.PotatoGarden(5)
gardener = Garden.Gardener()

grow_potatoes(my_garden, gardener)

 
 ****************************************
 
 

class Rainbow:
    element = 'Радуга'


class Lava:
    element = 'Лава'


class Dust:
    element = 'Пыль'


class Lightning:
    element = 'Молния'


class Dirt:
    element = 'Грязь'


class Steam:
    element = 'Пар'


class Storm:
    element = 'Шторм'


class Light:
    element = 'Свет'

    def __add__(self, other):

        if isinstance(other, Water):
            return Rainbow()
        else:
            return None


class Water:
    element = 'Вода'

    def __add__(self, other):
        if isinstance(other, Air):
            return Storm()
        elif isinstance(other, Fire):
            return Steam()
        elif isinstance(other, Earth):
            return Dirt()
        elif isinstance(other, Light):
            return Rainbow()
        else:
            return None


class Air:
    element = 'Воздух'

    def __add__(self, other):
        if isinstance(other, Water):
            return Storm()
        elif isinstance(other, Fire):
            return Lightning()
        elif isinstance(other, Earth):
            return Dust()
        else:
            return None


class Fire:
    element = 'Огонь'

    def __add__(self, other):
        if isinstance(other, Water):
            return Steam()
        elif isinstance(other, Air):
            return Lightning()
        elif isinstance(other, Earth):
            return Lava()
        else:
            return None


class Earth:
    element = 'Земля'

    def __add__(self, other):
        if isinstance(other, Water):
            return Dirt()
        elif isinstance(other, Air):
            return Dust()
        elif isinstance(other, Fire):
            return Lava()
        return None


fire = Fire()
water = Water()
new_element = fire + water
if not new_element:
    print('Результат не определён'.format(new_element))
else:
    print('{0} + {1} = {2}'.format(
        fire.element,
        water.element,
        new_element.element))


 
 ****************************************
 
 class House:

    def __init__(self, refrigerator_with_food=50, bedside_table_with_money=0):
        self.refrigerator_with_food = refrigerator_with_food
        self.bedside_table_with_money = bedside_table_with_money

    def change_amount_money(self, change_money):
        if change_money:
            self.bedside_table_with_money += 10
        elif not change_money:
            self.bedside_table_with_money -= 10

    def change_amount_of_food(self, change_food):
        if not change_food:
            self.refrigerator_with_food -= 10
        elif change_food:
            self.refrigerator_with_food += 10


class Human:
    house = House()

    def __init__(self, name, satiety=50):
        self.satiety = satiety
        self.name_of_human = name

    def work(self):
        change_money = True
        self.satiety -= 10
        self.house.change_amount_money(change_money)
        print('Уровень сытости понизился до значения {}. Количество денег увеличилось до значения {}.'.format(
            self.satiety,
            self.house.bedside_table_with_money
        ))

    def eat(self):
        if self.house.refrigerator_with_food >= 10:
            change_food = False
            self.satiety += 10
            self.house.change_amount_of_food(change_food)
            print('Уровень сытости поднялся до значения {}, количество еды в холодильнике '
                  ' уменьшилось до значения {}.'.format(
                self.satiety,
                self.house.refrigerator_with_food
            ))
        else:
            print('Поесть не удалось, в холодильнике слишком мало еды.')

    def play(self):
        self.satiety -= 10
        print('Уровень сытости понизился до значения {}.'.format(self.satiety))

    def go_to_shop(self):
        if self.house.bedside_table_with_money >= 10:
            change_food = True
            change_money = False
            self.house.change_amount_of_food(change_food)
            self.house.change_amount_money(change_money)
            print('Количество продуктов в холодильнике увеличилось до значения {},'
                  ' количество денег уменьшилось до значения {}.'.format(
                    self.house.refrigerator_with_food,
                    self.house.bedside_table_with_money
                  ))
        else:
            print('Слишком мало денег для похода в магазин.')

    def is_live(self):
        if self.satiety < 0:
            return False
        else:
            return True

 
 ****************************************
 
 import Human_and_House
import random


def survive(pair_of_humans):
    count_of_day = 0
    count_of_death = 0

    while count_of_day != 365:
        count_of_day += 1
        print('\nДень {}'.format(count_of_day))

        for index in range((len(pair_of_humans))):
            if not pair_of_humans[index].is_live():
                print('{} умер(ла) от голода.'.format(pair_of_humans[index].name_of_human))
                count_of_death += 1
                continue
            else:
                print('{} действует:'.format(pair_of_humans[index].name_of_human))
                number_of_dice = random.randint(1, 6)
                if pair_of_humans[index].satiety < 20:
                    print('{} проголодался(ась) (уровень его сытости равен {}) и решил(а) поесть.'.format(
                        pair_of_humans[index].name_of_human,
                        pair_of_humans[index].satiety
                    ))
                    pair_of_humans[index].eat()
                elif pair_of_humans[index].house.refrigerator_with_food < 10:
                    print('В холодильнике мало еды (значение = {}), {} пошел(ла) в магазин.'.format(
                        pair_of_humans[index].house.refrigerator_with_food,
                        pair_of_humans[index].name_of_human
                    ))
                    pair_of_humans[index].go_to_shop()
                elif pair_of_humans[index].house.bedside_table_with_money < 50:
                    print('Дома недостаточно денег (значение = {}), {} пошел(ла) работать.'.format(
                        pair_of_humans[index].house.bedside_table_with_money,
                        pair_of_humans[index].name_of_human
                    ))
                    pair_of_humans[index].work()
                elif number_of_dice == 1:
                    print('{}  решил(а) поработать.'.format(pair_of_humans[index].name_of_human))
                    pair_of_humans[index].work()
                elif number_of_dice == 2:
                    print('{}  решил(а) поесть.'.format(pair_of_humans[index].name_of_human))
                    pair_of_humans[index].eat()
                else:
                    print('{}  решил(а) поиграть.'.format(pair_of_humans[index].name_of_human))
                    pair_of_humans[index].play()

        if not pair_of_humans[0].is_live() and not pair_of_humans[1].is_live():
            print('\nЖильцы не смогли справится с тяготами жизни и умерли.')
            break

    if count_of_death == 0:
        print('\nЖильцы успешно смогли прожить целый год!')
    if count_of_death == 1:
        print('\nК сожалению, только один жилец успешно смог прожить целый год!')


pair_of_tenants = [Human_and_House.Human('Артем'), Human_and_House.Human('Анна')]

survive(pair_of_tenants)

 
 ****************************************
 
 import random


class Card:
    def __init__(self, rank, suit):
        self.rank = rank
        self.suit = suit

    def card_value(self, excess=False):
        if self.rank in 'JQK':
            return 10
        elif excess:
            return ' A23456789T'.index(self.rank)
        elif not excess:
            return '  23456789TA'.index(self.rank)

    def __str__(self):
        return '{}{}'.format(self.rank, self.suit)

class Deck:
    def __init__(self):
        ranks = '23456789TJQKA'
        suits = 'DCHS'
        self.cards = [Card(r, s) for r in ranks for s in suits]
        random.shuffle(self.cards)

    def get_cards(self, hand, number_card=1):

        for _ in range(number_card):
            hand.append(random.choice(self.cards))
            used_card = hand[len(hand) - 1]
            self.cards.remove(used_card)
        return hand


class Gambler:

    def __init__(self, name, hand=list()):
        self.name = name
        self.hand_of_player = hand

    def info(self):
        print('Карты в руке пользователя:')
        for card in self.hand_of_player:
            print(card, end=' ')
 
 ****************************************
 
 import Blackjack


def gamble_blackjack(player, computer,  excess=False):
    point_player = 0
    point_computer = 0
    while True:
        try:
            player.info()
            action = input('\nЕще или стоп? ')
            if (action.lower() == 'еще') or (action.lower() == 'ещё'):
                cards.get_cards(player.hand_of_player)
                cards.get_cards(computer)
            elif (action.lower() != 'еще') and (action.lower() != 'ещё') and (action.lower() != 'стоп'):
                raise BaseException('Ошибка ввода: нужно ввести либо слово "еще" или "стоп".\n')
            elif action == 'стоп':
                for card in player.hand_of_player:
                    point_player += card.card_value(excess)
                    if point_player >= 21:
                        excess = True

                excess = False

                for card in computer:
                    point_computer += card.card_value(excess)

                print('Карты в руке дилера:')
                for card in computer:
                    print(card, end=' ')

                print()

                if (point_player == 21) and (point_computer < 21):
                    print('Количество очков {} - {}, количество очков дилера - {}. Игрок победил!'.format(
                        player.name,
                        point_player,
                        point_computer
                    ))
                elif (point_player < 21) and (point_computer == 21):
                    print('Количество очков {} - {}, количество очков дилера - {}. Дилер победил!'.format(
                        player.name,
                        point_player,
                        point_computer
                    ))
                elif point_player > 21:
                    print('Количество очков {} - {}, количество очков дилера - {}. Перебор. Игрок проиграл!'.format(
                        player.name,
                        point_player,
                        point_computer
                    ))
                elif (point_player < 21) and (point_player > point_computer):
                    print('Количество очков {} - {}, Количество очков дилера - {}. Игрок победил!'.format(
                        player.name,
                        point_player,
                        point_computer
                    ))
                elif (point_player < 21) and (point_player < point_computer) and (point_computer < 21):
                    print('Количество очков {} - {}, Количество очков дилера - {}. Игрок проиграл!'.format(
                        player.name,
                        point_player,
                        point_computer
                    ))
                elif (point_player < 21) and (point_computer > 21):
                    print('Количество очков {} - {}, Количество очков дилера - {}. У дилера перебор!'
                          ' Игрок победил!'.format(
                        player.name,
                        point_player,
                        point_computer
                    ))
                elif (point_player < 21) and (point_player == point_computer) or (point_player == 21) \
                        and (point_player == point_computer):
                    print(
                        'Количество очков {} - {}, Количество очков дилера - {}.  Ничья!'.format(
                            player.name,
                            point_player,
                            point_computer
                        ))
                break
        except BaseException as exc:
            print(exc)


computer_hand = list()
cards = Blackjack.Deck()
gambler = Blackjack.Gambler('Artem')

cards.get_cards(gambler.hand_of_player, 2)
cards.get_cards(computer_hand, 2)


gamble_blackjack(gambler, computer_hand)
 
 ****************************************
 
 import Tic_tac_toe


def play_game(first_player, second_player, deck):
    playing_deck.display_broad()
    while True:
        print('\nХодит {}  -{}'.format(first_player.name, first_player.chip))
        first_player.move(deck)
        winner = deck.check_winner(first_player.chip)
        if winner:
            print('\n{} победил! Игра окончена.'.format(first_player.name))
            break
        print('\nХодит {}  -{}'.format(second_player.name, second_player.chip))
        second_player.move(deck)
        winner = deck.check_winner(second_player.chip)
        if winner:
            print('\n{} победил! Игра окончена.'.format(second_player.name))
            break


playing_deck = Tic_tac_toe.Board()
player_1 = Tic_tac_toe.Player('Артем', '  X   ')
player_2 = Tic_tac_toe.Player('Павел', '  O   ')

play_game(player_1, player_2, playing_deck)

 
 ****************************************
 
 class Cell:

    def __init__(self, number, value):
        self.number_of_cell = number
        self.value_of_cell = value


class Board:

    def __init__(self, size_board=9):
        self.size_board = size_board
        self.broad = [[Cell(num, 'пустое')
                       for num in range(i_list, 3 + i_list)]
                      for i_list in range(1, self.size_board + 1, 3)]

    def display_broad(self):
        print('\n\t\tТекущее игровое поле:')
        for i_elem in self.broad:
            for j_elem in i_elem:
                print('|', j_elem.number_of_cell, j_elem.value_of_cell, '|', end=' ')
            print()

    def fill_in_cells(self, number, chip):

        cancellation_move = False
        for i_elem in self.broad:
            for j_elem in i_elem:
                if number == j_elem.number_of_cell:
                    if j_elem.value_of_cell == 'пустое':
                        j_elem.value_of_cell = chip
                        print('В клетку {} добавлено значение {}'.format(number, chip))
                    else:
                        print('Эта клетка занята. Выберите, пожалуйста, другую клетку для хода.')
                        cancellation_move = True

        return cancellation_move

    def check_winner(self, chip):

        game_over = False

        if (self.broad[0][0].value_of_cell == chip) and (self.broad[1][0].value_of_cell == chip) and \
                (self.broad[2][0].value_of_cell == chip):
            game_over = True
        elif (self.broad[0][1].value_of_cell == chip) and (self.broad[1][1].value_of_cell == chip) \
                and (self.broad[2][1].value_of_cell == chip):
            game_over = True
        elif (self.broad[0][2].value_of_cell == chip) and (self.broad[1][2].value_of_cell == chip) and \
                (self.broad[2][2].value_of_cell == chip):
            game_over = True
        elif (self.broad[0][0].value_of_cell == chip) and (self.broad[0][1].value_of_cell == chip) and \
                (self.broad[0][2].value_of_cell == chip):
            game_over = True
        elif (self.broad[1][0].value_of_cell == chip) and (self.broad[1][1].value_of_cell == chip) and \
                (self.broad[1][2].value_of_cell == chip):
            game_over = True
        elif (self.broad[2][0].value_of_cell == chip) and (self.broad[2][1].value_of_cell == chip) and \
                (self.broad[2][2].value_of_cell == chip):
            game_over = True
        elif (self.broad[0][0].value_of_cell == chip) and (self.broad[1][1].value_of_cell == chip) and \
                (self.broad[2][2].value_of_cell == chip):
            game_over = True
        elif (self.broad[2][0].value_of_cell == chip) and (self.broad[1][1].value_of_cell == chip) and \
                (self.broad[0][2].value_of_cell == chip):
            game_over = True

        return game_over


class Player:

    def __init__(self, name, chip):
        self.name = name
        self.chip = chip

    def move(self, board):
        while True:
            try:
                print('Выберите поле для хода (от 1 до 9): ', end=' ')
                number_of_cell = int(input())
                if str(number_of_cell) not in '123456789':
                    raise BaseException('Ошибка ввода: такой такой клетки на поле нет.')
                cancellation_move = board.fill_in_cells(number_of_cell, self.chip)
                if not cancellation_move:
                    break
            except ValueError:
                print('Ошибка ввода: необходимо вводить только числовые значения от 1 до 9')
            except BaseException as exc:
                print(exc)
        board.display_broad()
 
 ****************************************
 
 class Property:
    """
    Базовый класс, созданный для расчета налога.

    Args:
        worth (float): передается стоимость имущества

    Attributes:
        __worth (float): стоимость имущества
    """
    def __init__(self, worth):
        self.__worth = worth

    def get_worth(self):
        """
        Геттер для получения стоимости имущества

        :return: __worth
        :rtype: float
        """
        return self.__worth

    def rate_tax(self):
        """
        Метод для расчета налога,
        который будет переопределен в дочерних классах
        """
        pass


class Apartment(Property):
    """
    Класс Apartment. Родитель: Property

    __property_tax (int): ставка расчета налога на квартиру

    Args:
        worth (float): передается стоимость имущества
    """
    __property_tax = 1000

    def __init__(self, worth):
        super().__init__(worth)

    def rate_tax(self):
        """
        Метод для расчета налога

        :return: result (float)
        """
        result = self.get_worth() / self.__property_tax
        return result


class Car(Property):
    """
    Класс Car. Родитель: Property

    __car_tax (int): ставка расчета налога на квартиру

    Args:
        worth (float): передается стоимость имущества
    """

    __car_tax = 200

    def __init__(self, worth):
        super().__init__(worth)

    def rate_tax(self):
        """
        Метод для расчета налога

        :return: result (float)
        """
        result = self.get_worth() / self.__car_tax
        return result


class CountryHouse(Property):
    """
    Класс CountryHouse. Родитель: Property

    __country_house_tax (int): ставка расчета налога на квартиру

    Args:
        worth (float): передается стоимость имущества
    """
    __country_house_tax = 500

    def __init__(self, worth):
        super().__init__(worth)

    def rate_tax(self):
        """
        Метод для расчета налога

        :return: result (float)
        """
        result = self.get_worth() / self.__country_house_tax
        return result


def calculate_tax(name):
    """
    Функция calculate_tax, которая создает интерфейс программы
    для расчета налога.

    Args:
        name (str): имя человека

    :except ValueError: если в поля ввода, находящиеся в функции, вносятся нечисловые значения,
     то вызывается исключение.
    """
    print('Здравствуйте, {}!'.format(name))
    while True:
        try:
            money = float(input('Введите количество ваших средств: '))
            print('Выберите из списка имущество, которым Вы владеете: 1 - квартира, 2 - автомобиль, 3 - дача:', end=' ')
            choice_user = int(input())
            if choice_user == 1:
                cost_flat = float(input('Введите стоимость квартиры (в $): '))
                user_property_tax = Apartment(cost_flat)
                print('Налог на квартиру составляет {} $.'.format(user_property_tax.rate_tax()))
                if money < user_property_tax.rate_tax():
                    print('Для оплаты налога не хватает средств в размере {} $.'.format(
                        user_property_tax.rate_tax() - money))
            elif choice_user == 2:
                cost_car = float(input('Введите стоимость автомобиля (в $): '))
                user_car_tax = Car(cost_car)
                print('Налог на автомобиль составляет {} $.'.format(user_car_tax.rate_tax()))
                if money < user_car_tax.rate_tax():
                    print('Для оплаты налога не хватает средств в размере {} $.'.format(user_car_tax.rate_tax() - money))
            elif choice_user == 3:
                cost_country_house = float(input('Введите стоимость дачи (в $): '))
                user_country_house_tax = CountryHouse(cost_country_house)
                print('Налог на дачу составляет {} $'.format(user_country_house_tax.rate_tax()))
                if money < user_country_house_tax.rate_tax():
                    print('Для оплаты налога не хватает средств в размере {} $.'.format(
                        user_country_house_tax.rate_tax() - money))
        except ValueError:
            print('Ошибка ввода: необходимо ввести числовое значение. Введите данные заново.')
        else:
            break


name_user = input('Введите ваше имя: ')

calculate_tax(name_user)

 
 ****************************************
 
 import random


class Karma:
    """Класс Karma, созданный возвращения очков кармы и генерации значений для вызова исключений.

    __max_karma (int): верхнее значение очков кармы.

    Attributes:
        day_karma (int): количество кармы, приходящей за один день
        probability_exception (int): значение для вызова исключения
        probability_concrete_exception (int): значение для вызова конкретного исключения.
    """
    __max_karma = 500

    def __init__(self):
        self.day_karma = 0
        self.probability_exception = 0
        self.probability_concrete_exception = 0

    def get_max_karma(self):
        """
        Геттер для получения максимальной кармы

        :return: __max_karma
        :rtype: int
        """
        return self.__max_karma

    def get_day_karma(self):
        """
        Метод для получения дневной кармы в случайном значении от 1 до 7

        :return: day_karma
        :rtype: int
        """
        self.day_karma = random.randint(1, 7)
        return self.day_karma

    def get_probability_exception(self):
        """
        Метод для получения случайного значения от 1 до 10 для вызова исключений

        :return: probability_exception
        :rtype: int
        """
        self.probability_exception = random.randint(1, 10)
        return self.probability_exception

    def get_probability_concrete_exception(self):
        """
        Метод для получения случайного значения от 1 до 5 для вызова конкретного исключения

        :return: probability_concrete_exception
        :rtype: int
        """
        self.probability_concrete_exception = random.randint(1, 5)
        return self.probability_concrete_exception


class KillError(Exception):
    """
    Класс KillError. Родитель - Exception. Создан для вызова исключения KillError
    """
    pass


class DrunkError(Exception):
    """
    Класс DrunkError. Родитель - Exception. Создан для вызова исключения DrunkError.
    """
    pass


class CarCrashError(Exception):
    """
    Класс CarCrashError. Родитель - Exception. Создан для вызова исключения CarCrashError.
    """
    pass


class GluttonyError(Exception):
    """
    Класс GluttonyError. Родитель - Exception. Создан для вызова исключения GluttonyError.
    """
    pass


class DepressionError(Exception):
    """
    Класс DepressionError. Родитель - Exception. Создан для вызова исключения DepressionError.
    """
    pass


def live_one_day(karma):
    """
    Функция live_one_day, которая возвращает количество очков дневной кармы, если исключение не было вызвано,
    в противном случае возвращается None, а исключение записывается в файл karma.log.

    Args:
        karma (class Karma): экземпляр класса Karma

    :raise DrunkError, KillError, CarCrashError, GluttonyError, DepressionError (все эти исключения
    генерируются случайным образом с помощью методов класса Karma).
    """
    try:
        if karma.get_probability_exception() == 10:
            if karma.get_probability_concrete_exception() == 1:
                raise DrunkError
            elif karma.get_probability_concrete_exception() == 2:
                raise KillError
            elif karma.get_probability_concrete_exception() == 3:
                raise CarCrashError
            elif karma.get_probability_concrete_exception() == 4:
                raise GluttonyError
            elif karma.get_probability_concrete_exception() == 5:
                raise DepressionError
    except (DrunkError, KillError, CarCrashError,  GluttonyError, DepressionError) as exc:
        with open('karma.log', 'a', encoding='utf-8') as file_with_errors:
            if type(exc) == DrunkError:
                str_of_error = get_exception('DrunkError')
            elif type(exc) == KillError:
                str_of_error = get_exception('KillError')
            elif type(exc) == CarCrashError:
                str_of_error = get_exception('CarCrashError')
            elif type(exc) == GluttonyError:
                str_of_error = get_exception('GluttonyError')
            elif type(exc) == DepressionError:
                str_of_error = get_exception('DepressionError')
            file_with_errors.write(str_of_error + '\n')
        return str_of_error
    else:
        return karma.get_day_karma()


def get_exception(exception):
    """
    Функция get_exception, которая возвращает описание полученного функцией названия исключения
    (DrunkError, KillError, CarCrashError, GluttonyError, DepressionError)

    Args:
        exception (str): название исключения.
    """

    if exception == 'DrunkError':
        return 'Сегодня буддист-программист выпил - карма за этот день не накопилась'
    elif exception == 'KillError':
        return 'Сегодня буддист-программист убил таракана - карма за этот день не накопилась'
    elif exception == 'CarCrashError':
        return 'Сегодня буддист-программист разбил свою машину - карма за этот день не накопилась'
    elif exception == 'GluttonyError':
        return 'Сегодня буддист-программист ходил в Макдоналдс - карма за этот день не накопилась'
    elif exception == 'DepressionError':
        return 'Сегодня буддист-программист депрессует - карма за этот день не накопилась'


def save_up_karma(karma):
    """
    Функция save_up_karma, которая накапливает значение кармы

    Args:
        karma (class Karma): экземпляр класса Karma
    """

    sum_of_karma = 0
    counter_of_days = 0

    while True:
        counter_of_days += 1
        print('День {}'.format(counter_of_days))
        point_of_karma = live_one_day(karma)
        if isinstance(point_of_karma, int):
            sum_of_karma += point_of_karma
        else:
            print('{}. Из-за неподобающего поведения буддиста-программиста очки кармы ему начислены не были.'.format(
                point_of_karma
            ))

        if sum_of_karma < karma.get_max_karma():
            print('Текущее значение очков кармы {} из {}'.format(sum_of_karma, karma.get_max_karma()))
        elif sum_of_karma >= karma.get_max_karma():
            print('Набрано необходимое количество очков кармы! Буддист-программист достиг просветления!')
            break


karma_of_buddhist = Karma()

save_up_karma(karma_of_buddhist)




 
 ****************************************
 
 class MyDict(dict):
    """
    Класс MyDict. Родитель: dict, созданный для инициализации собственного словаря.
    """
    def get(self, key, default=None):
        """
        Переопределенный метод get, который возвращает значение ключа, в случае отсутствия ключа в словаре возвращает 0

        :return: get (либо значение ключа, либо 0 (int))
        """

        return super().get(key, 0)


my_dict = MyDict({"one": 1, "two": 2})
print(my_dict.get("one"))
print(my_dict.get("tree"))

 
 ****************************************
 
 import random


class Person:
    """
    Базовый класс, созданный для описания человека.

       Args:
           name (str): передается имя человека
           surname (str): передается фамилия человека
           age (int): передается возраст человека

       Attributes:
           __name (str): имя человека
           __surname (str): фамилия человека
           __age (int): возраст человека (до установления сеттером имеет значение 0)
       """

    def __init__(self, name, surname, age):
        self.__name = name
        self.__surname = surname
        self.__age = 0
        self.set_age(age)

    def get_name(self):
        """
        Геттер для получения имени человека

        :return: __name
        :rtype: str
        """
        return self.__name

    def get_surname(self):
        """
        Геттер для получения фамилии человека

        :return: __surname
        :rtype: str
        """
        return self.__surname

    def get_age(self):
        """
        Геттер для получения возраста человека

        :return: __age
        :rtype: int
        """
        return self.__age

    def set_age(self, age):
        """
        Сеттер для установления возраста человека

        :param age: возраст
        :type age: int
        :raise Exception: если возраст не в диапазоне от 18 до 68 лет, то вызывается исключение
        """

        if age in range(18, 69):
            self.__age = age
        else:
            raise Exception('Недопустимый возраст')

    def __str__(self):
        """
        Магические метод str для отображения информации об объекте класса для пользователей.

        :return str c атрибутами класса Person
        """
        return 'имя: {}\nфамилия: {}\nвозраст: {}'.format(
            self.__name,
            self.__surname,
            self.__age)


class Employee(Person):
    """
    Класс Employee. Родитель: Person. Этот дочерний класс содержит метод для
    расчета заработной платы сотрудников компании.
    """

    def calculate_salary(self):
        """
        Метод для расчета заработной платы сотрудников компании, содержащий оператор-заглушку pass.
        """
        pass


class Manager(Employee):
    """
        Класс Manager. Родитель: Employee. Создан для расчета заработной платы менеджеров компании
        и отображения информации о них.

        Attributes:
            salary(int): заработная плата менеджеров компании.
        """
    salary = 13000

    def calculate_salary(self):
        """
        Переопределенный метод для расчета заработной платы сотрудников компании.

        :return: salary (int)
        """

        return self.salary

    def __str__(self):
        """
        Переопределенный магические метод str для отображения информации об объекте класса для пользователей.

        :return str c атрибутами классов Person и Manger.
        """

        data = super().__str__()
        salary = self.calculate_salary()
        result = '\n'.join((str(data), 'Заработная плата: ' + str(salary)))
        return result


class Agent(Employee):
    """
    Класс Agent. Родитель: Employee. Создан для расчета заработной платы агентов по продажам компании
    и отображения информации о них.

    Args:
        name (str): передается имя человека
        surname (str): передается фамилия человека
        age (int): передается возраст человека

    Attributes:
        name (str): имя человека
        surname (str): фамилия человека
        age (int): возраст человека
        salary (int): ставка сотрудника
        volume_of_sales (int): объем продаж (случайное число от 1000 до 10000)
    """

    def __init__(self, name, surname, age):
        super().__init__(name, surname, age)
        self.salary = 5000
        self.volume_of_sales = random.randint(1000, 10000)

    def calculate_salary(self):
        """
        Переопределенный метод для расчета заработной платы сотрудников компании.

        :return: result (float)
        """

        result = self.salary + ((self.volume_of_sales * 5) / 100)
        return result

    def __str__(self):
        """
        Переопределенный магические метод str для отображения информации об объекте класса для пользователей.

        :return str c атрибутами класса Person и полученным значением из
        метода расчета заработной платы дочернего класса Agent.
        """

        data = super().__str__()
        salary = self.calculate_salary()
        result = '\n'.join((str(data), 'Заработная плата: ' + str(salary)))
        return result


class Worker(Employee):
    """
        Класс Worker. Родитель: Employee. Создан для расчета заработной платы рабочих  компании
        и отображения информации о них.

        Args:
            name (str): передается имя человека
            surname (str): передается фамилия человека
            age (int): передается возраст человека

        Attributes:
            name (str): имя человека
            surname (str): фамилия человека
            age (int): возраст человека
            hours_worked (int): количество отработанных часов (случайное число от 1 до 60)
        """

    def __init__(self, name, surname, age):
        super().__init__(name, surname, age)
        self.hours_worked = random.randint(1, 60)

    def calculate_salary(self):
        """
        Переопределенный метод для расчета заработной платы сотрудников компании.

        :return: result (int)
        """
        result = 100 * self.hours_worked
        return result

    def __str__(self):
        """
        Переопределенный магические метод str для отображения информации об объекте класса для пользователей.

        :return str c атрибутами класса Person и полученным значением из
        метода расчета заработной платы дочернего класса Worker.
        """

        data = super().__str__()
        salary = self.calculate_salary()
        result = '\n'.join((str(data), 'Заработная плата: ' + str(salary)))
        return result
 
 ****************************************
 
 import Employees_of_company


def fill_up_employees(workers):
    """
    Функция fill_up_employees заполняет список сотрудников компании.

    Args:
        workers (list): пустой список

    :except ValueError: если в поля ввода имени объекта age_employee вносятся нечисловые значения,
     то вызывается исключение.
    """

    for num in range(1, 10):
        print('Введите данные о {} работнике.'.format(num))
        name_employee = input('Введите имя работника: ')
        surname_employee = input('Введите фамилию работника: ')
        while True:
            try:
                age_employee = int(input('Введите возраст работника: '))
                if num <= 3:
                    workers.append(Employees_of_company.Manager(name_employee, surname_employee, age_employee))
                elif num == 4 or num <= 6:
                    workers.append(Employees_of_company.Agent(name_employee, surname_employee, age_employee))
                elif num == 7 or num <= 9:
                    workers.append(Employees_of_company.Worker(name_employee, surname_employee, age_employee))
                print()
            except ValueError:
                print('Ошибка ввода: необходимо вводить только числовые значения. Введите возраст работника снова.')
            else:
                break


def display_employees(workers):
    """
    Функция display_employees отображает информацию о сотрудниках компании.

    Args:
        workers (list): список сотрудников
    """
    for index, elem in enumerate(workers):
        print('Данные о {} работнике:'.format(index + 1))
        print(elem, '\n')


employees = list()

fill_up_employees(employees)
display_employees(employees)






 
 ****************************************
 
 import math
import random


class Car:
    """
    Базовый класс, создающий объект автомобиль.

    Args:
        x (float): значение x
        y (float): значение y
        angle (float): угол направления движения

    Attributes:
        __x (float): значение x
        __y (float): значение y
        __angle (float): угол направления движения (до установления сеттером имеет значение 0)
    """

    def __init__(self, x, y, angle):
        self.__x = x
        self.__y = y
        self.__angle = 0
        self.set_age(angle)

    def get_x(self):
        """
        Геттер для получения значения x

        :return: __x
        :rtype: float
        """
        return round(self.__x, 2)

    def get_y(self):
        """
        Геттер для получения значения y

        :return: __y
        :rtype: float
         """
        return round(self.__y, 2)

    def get_angle(self):
        """
        Геттер для получения значения угла направления движения

        :return: __angle
        :rtype: float
        """
        return self.__angle

    def set_age(self, angle):
        """
        Сеттер для установления корректного угла направления движения

        :param angle: угол
        :type angle: float
        :raise Exception: если угол не в диапазоне от 0 до 360 градусов, то вызывается исключение
        """

        if angle in range(0, 361):
            self.__angle = angle
        else:
            raise Exception('Недопустимый угол.')

    def move(self, distance):
        """
        Метод для расчета точки, в которую приедет автомобиль

        :param distance: расстояние
        :type distance: float
        """
        new_point_x = distance * math.cos(math.radians(self.__angle))
        new_point_y = distance * math.sin(math.radians(self.__angle))

        if self.__x != 0 and self.__y != 0:
            self.__x += new_point_x
            self.__y += new_point_y
        else:
            self.__x = new_point_x
            self.__y = new_point_y

    def turn(self, new_angle):
        """
        Метод для изменения угла направления движения. Содержит встроенный сеттер проверки корректности угла

        :param new_angle: угол

        :type new_angle: float
        :raise Exception: если угол не в диапазоне от 0 до 360 градусов, то вызывается исключение
        """

        if new_angle in range(0, 361):
            self.__angle = new_angle
        else:
            raise Exception('Недопустимый угол.')


class Bus(Car):
    """
    Класс Bus. Родитель: Car, создающий объект автобус

    Args:
        x (float): значение x
        y (float): значение y
        angle (float): угол направления движения

    Attributes:
        __income (float): доход от продажи билетов
        __number_of_passengers (float): количество пассажиров
    """

    def __init__(self, x, y, angle):
        super().__init__(x, y, angle)
        self.__income = 0
        self.__number_of_passengers = 0

    def get_money(self):
        """
        Геттер для получения значения дохода от продажи билетов

        :return: __income
        :rtype: int
        """
        return self.__income

    def get_number_of_passengers(self):
        """
        Геттер для получения количества пассажиров

        :return: __number_of_passengers
        :rtype: int
        """
        return self.__number_of_passengers

    def enter_into_bus(self):
        """
        Метод для увеличения числа пассажиров в автобусе.
        """
        randon_number_of_passengers = random.randint(0, 25)
        if self.__number_of_passengers >= 101:  # лимит мест в автобусе
            print('В автобусе нет свободных мест. Никто не смог войти.')
        elif (self.__number_of_passengers + randon_number_of_passengers) > 101:
            randon_number_of_passengers = 101 - self.__number_of_passengers
            self.__number_of_passengers += randon_number_of_passengers
            print('В автобус вошло {} человек(а). Текущее количество человек в автобусе - {}'.format(
                randon_number_of_passengers,
                self.__number_of_passengers
            ))
        else:
            self.__number_of_passengers += randon_number_of_passengers
            print('В автобус вошло {} человек(а). Текущее количество человек в автобусе - {}'.format(
                randon_number_of_passengers,
                self.__number_of_passengers
            ))

    def alight_from_bus(self):
        """
        Метод для уменьшения числа пассажиров в автобусе.
        """
        randon_number_of_passengers = random.randint(0, 25)
        if self.__number_of_passengers == 0:
            print('Автобус пуст. Некого высаживать.')
        elif self.__number_of_passengers - randon_number_of_passengers < 0:
            randon_number_of_passengers = self.__number_of_passengers
            self.__number_of_passengers = 0
            print('Из автобуса вышло {} человека. Текущее количество человек в автобусе - {}'.format(
                randon_number_of_passengers,
                self.__number_of_passengers
            ))
        else:
            self.__number_of_passengers -= randon_number_of_passengers
            print('Из автобуса вышло {} человека. Текущее количество человек в автобусе - {}'.format(
                randon_number_of_passengers,
                self.__number_of_passengers
            ))

    def move(self, distance):
        """
        Переопределенный метод для расчета точки, в которую приедет автобус. Добавлено увеличение дохода от продажи
        билетов за проезд

        :param distance: расстояние
        :type distance: float
        """
        super().move(distance)
        self.__income += (1 * distance) * self.__number_of_passengers  # Цена проезда для одного пассажира равна 1
                                                                       # за каждую ед. дистанции
 
 ****************************************
 
 import Car_and_Bus


def drive_car(vehicle):
    """
    Функция drive_car создает интерфейс для управления автомобилем.

    Args:
        vehicle (class Car): объект класса Car

    :except ValueError: если в поля ввода вносятся нечисловые значения или в случае дробного числа используется ","
    вместо точки, то вызывается исключение.
    """
    while True:
        try:
            print('В процессе управления автомобилем Вам доступны два действия: 1 - поехать в выбранном направлении; '
                  '2 - повернуть (изменить текущее направление).\nПримечание: для завершения поездки введите 3.')
            choice_action = int(input('Выберите действие: '))
            if choice_action == 1:
                distance = float(input('Введите расстояние, которое хотите проехать: '))
                vehicle.move(distance)
                print('Автомобиль проехал указанное расстояние, в указанном направлении. Теперь его координаты '
                      'следующие: '
                      'х = {}, y = {}.'.format(vehicle.get_x(), vehicle.get_y()))
            elif choice_action == 2:
                angle = float(input('Введите новое направление движения (угол): '))
                vehicle.turn(angle)
                print('Угол направления движения успешно изменен.')
            elif choice_action == 3:
                print('Поездка окончена.')
                break
            elif choice_action != 1 and choice_action != 2 and choice_action != 3:
                print('Ошибка ввода: необходимо ввести "1", "2" или "3".')
        except ValueError:
            print('Ошибка ввода: необходимо вводить только числовые значения. '
                  'В случае дробного числа используйте "." вместо запятой.')


def drive_bus(autobus):
    """
    Функция drive_bus создает интерфейс для управления автобусом.

    Args:
        autobus (class Bus): объект класса Bus

    :except ValueError: если в поля ввода вносятся нечисловые значения или в случае дробного числа используется ","
    вместо точки, то вызывается исключение.
    """
    while True:
        try:
            print('В процессе управления автобусом Вам доступны четыре действия:\n1 - поехать в выбранном направлении; '
                  '\n2 - повернуть (изменить текущее направление);\n3 - принять новых пассажиров;'
                  '\n4 - высадить пассажиров.'
                  '\nПримечание: для завершения поездки введите 5.')
            choice_action = int(input('Выберите действие: '))
            if choice_action == 1:
                distance = float(input('Введите расстояние, которое хотите проехать: '))
                autobus.move(distance)
                print('Автобус проехал указанное расстояние, в указанном направлении. Теперь его координаты '
                      'следующие: х = {}, y = {}.'
                      '\nТекущее количество пассажиров - {}.\nЗаработано средств за все время работы - {}.'.format(
                       autobus.get_x(),
                       autobus.get_y(),
                       autobus.get_number_of_passengers(),
                       autobus.get_money()
                      ))
            elif choice_action == 2:
                angle = float(input('Введите новое направление движения (угол): '))
                autobus.turn(angle)
                print('Угол направления движения успешно изменен.')
            elif choice_action == 3:
                autobus.enter_into_bus()
            elif choice_action == 4:
                autobus.alight_from_bus()
            elif choice_action == 5:
                print('Поездка окончена.')
                break
            elif choice_action != 1 and choice_action != 2 and choice_action != 3:
                print('Ошибка ввода: необходимо ввести "1", "2" или "3".')
        except ValueError:
            print('Ошибка ввода: необходимо вводить только числовые значения. '
                  'В случае дробного числа используйте "." вместо запятой.')


print('Введите координаты изначального местоположения вашего средства передвижения, а также угол,'
      ' описывающий направление движения.')
while True:
    try:
        coordinate_x = float(input('Введите точку x: '))
        coordinate_y = float(input('Введите точку y: '))
        angle_of_direction = float(input('Угол описывающий направление движения: '))

        print('Выберите средство передвижения, которым хотите управлять (1 - автомобиль, 2 - автобус): ', end='')
        choice_user = int(input())
    except ValueError:
        print('Ошибка ввода: необходимо вводить только числовые значения. В случае дробного числа используется "." '
              'вместо запятой.')
    else:
        break

if choice_user == 1:
    car = Car_and_Bus.Car(x=coordinate_x, y=coordinate_y, angle=angle_of_direction)
    drive_car(car)

if choice_user == 2:
    bus = Car_and_Bus.Bus(x=coordinate_x, y=coordinate_y, angle=angle_of_direction)
    drive_bus(bus)



 
 ****************************************
 
 import random


class House:
    """
    Класс House, создающий объект дом.

    __refrigerator_with_food (int): значение количества еды в доме
    __bedside_table_with_money (int): значение количества денег в доме
    __food_for_cat (int): значение количества корма для кота в доме
    __dirt_in_house (int): значение количества грязи в доме
    __bought_coat (int): значение общего количества купленных шуб
    __earned_money (int): значение общего количества заработанных денег
    __food_eaten (int): значение общего количества съеденных продуктов
    __cat_food_eaten (int): значение общего количества съеденного кошачьего корма
    """
    __refrigerator_with_food = 50
    __bedside_table_with_money = 100
    __food_for_cat = 30
    __dirt_in_house = 0
    __bought_coat = 0
    __earned_money = 0
    __food_eaten = 0
    __cat_food_eaten = 0

    def get_refrigerator_with_food(self):
        """
        Геттер для получения значения количества еды в доме

        :return: __refrigerator_with_food
        :rtype: int
        """
        return self.__refrigerator_with_food

    def get_bedside_table_with_money(self):
        """
        Геттер для получения значения количества денег в доме

        :return: __bedside_table_with_money
        :rtype: int
        """
        return self.__bedside_table_with_money

    def get_food_for_cat(self):
        """
        Геттер для получения значения количества корма для кота в доме

        :return: __bedside_table_with_money
        :rtype: int
        """
        return self.__food_for_cat

    def get_dirt_in_house(self):
        """
        Геттер для получения значения количества грязи в доме

        :return: __dirt_in_house
        :rtype: int
        """
        return self.__dirt_in_house

    def get_bought_coat(self):
        """
        Геттер для получения значения общего количества купленных шуб

        :return: __bought_coat
        :rtype: int
        """
        return self.__bought_coat

    def get_earned_money(self):
        """
        Геттер для получения значения количества заработанных денег

        :return: __earned_money
        :rtype: int
        """
        return self.__earned_money

    def get_food_eaten(self):
        """
        Геттер для получения значения общего количества съеденных продуктов

        :return: __food_eaten
        :rtype: int
        """
        return self.__food_eaten

    def get_cat_food_eaten(self):
        """
        Геттер для получения значения общего количества съеденного кошачьего корма

        :return: __cat_food_eaten
        :rtype: int
        """
        return self.__cat_food_eaten

    def change_amount_money(self, change_money, amount_money=150):
        """
        Метод для расчета движения денежных средств, имеющихся в доме


        :param change_money: булево значение, если True - количество денег увеличивается, если False - уменьшается
        :type change_money: bool

        :param amount_money: сумма денег, которая изменит количество денег в доме (по умолчанию 150)
        :type change_money: int
        """
        if change_money:
            self.__bedside_table_with_money += amount_money
            self.__earned_money += amount_money
        elif not change_money:
            if amount_money == 350:
                self.__bedside_table_with_money -= amount_money
                self.__bought_coat += 1
            else:
                self.__bedside_table_with_money -= amount_money

    def change_amount_of_food(self, change_food, volume_food):
        """
        Метод для расчета изменения количества продуктов в доме

        :param change_food: булево значение, если True - количество продуктов увеличивается, если False - уменьшается
        :type change_food: bool

        :param volume_food: объем продуктов, который изменит количество продуктов в доме
        :type volume_food: int
        """
        if not change_food:
            self.__refrigerator_with_food -= volume_food
            self.__food_eaten += volume_food
        elif change_food:
            self.__refrigerator_with_food += volume_food

    def change_amount_of_food_for_cat(self, change_food_for_cat, volume_food_for_cat):
        """
        Метод для расчета изменения количества корма для кота в доме

        :param change_food_for_cat: булево значение, если True - количество корма для кота увеличивается,
         если False - уменьшается
        :type change_food_for_cat: bool

        :param volume_food_for_cat: объем корма для кота, который изменит количество корма в доме
        :type volume_food_for_cat: int
        """
        if not change_food_for_cat:
            self.__food_for_cat -= volume_food_for_cat
            self.__cat_food_eaten += volume_food_for_cat
        elif change_food_for_cat:
            self.__food_for_cat += volume_food_for_cat

    def change_amount_of_dirt_in_house(self, clean_house=False, clean_up_dirt=0):
        """
        Метод для расчета изменения количества грязи в доме

        :param clean_house: булево значение, если True - количество грязи увеличивается,
         если False - уменьшается (по умолчанию False)
        :type clean_house: bool

        :param clean_up_dirt: количество убранной грязи, который уменьшить объем грязи в доме (по умолчанию 0)
        :type clean_up_dirt: int
        """

        if not clean_house:
            self.__dirt_in_house += 5
            print('Количество грязи увеличилось. '
                  'Текущее значение совокупности бардака в доме составляет {}.'.format(
                   self.get_dirt_in_house()
                  ))
        else:
            self.__dirt_in_house -= clean_up_dirt


class Tenant:
    """
    Класс Tenant, создающий объект жилец.

    Args:
        name (str): передается имя объекта
        satiety (int) передается уровень сытости объекта

    Attributes:
        house (class House): объект класса House
        __name (str) имя объекта
        __satiety (int) уровень сытость объекта

    """
    house = House()

    def __init__(self, name, satiety):
        self.__name = name
        self.__satiety = satiety

    def get_name(self):
        """
        Геттер для получения имени объекта

        :return: __name
        :rtype: str
        """
        return self.__name

    def get_satiety(self):
        """
        Геттер для получения уровня сытости объекта

        :return: __satiety
        :rtype: int
        """
        return self.__satiety

    def eat(self):
        """
        Метод, который создает взаимодействие жильцов с объектом класса House (метод change_amount_of_food),
        направлен на повышение уровня сытости жильцов.
        """
        change_food = False
        self.increase_satiety(30)
        self.house.change_amount_of_food(change_food, 30)
        print('{} съел(а) {} единиц еды. Уровень сытости поднялся до значения {}, количество еды в холодильнике'
              ' уменьшилось до значения {}.'.format(
                self.get_name(),
                30,
                self.get_satiety(),
                self.house.get_refrigerator_with_food()
              ))

    def increase_satiety(self, volume_food):
        """
        Метод, который повышает уровень сытости жильцов.

        :param volume_food: числовой показатель (объем продуктов), который повысит уровень сытости жильцов
        :type volume_food: int
        """
        self.__satiety += volume_food

    def decrease_satiety(self, fall_satiety):
        """
        Метод, который понижает уровень сытости жильцов.

        :param fall_satiety: числовой показатель, который понижает уровень сытости жильцов
        :type fall_satiety: int
        """
        self.__satiety -= fall_satiety

    def is_live(self):
        """
        Метод, который определяет не умер ли кто-то из жильцов от голода

        :return False, если жилец умер и True, если жилец жив
        """
        if self.get_satiety() <= 0:
            print('{} умер(ла) от голода.'.format(self.get_name()))
            return False
        else:
            return True


class Husband(Tenant):
    """
    Класс Husband. Родитель: Tenant. Класс создает объект муж.

    Args:
        name (str): передается имя объекта
        satiety (int) передается уровень сытости объекта (значение установлено по умолчанию)
        happiness (int) передается уровень счастья объекта (значение установлено по умолчанию)

    Attributes:
        __work_money (int) количество денег, зарабатываемых объектом за один рабочий день (значение 150)
        __happiness (int) уровень счастья объекта
    """

    def __init__(self, name, satiety=30, happiness=100):
        super().__init__(name, satiety)
        self.__work_money = 150
        self.__happiness = happiness

    def get_work_many(self):
        """
        Геттер для получения значения заработанных денег

        :return: __work_money
        :rtype: int
        """
        return self.__work_money

    def get_happiness(self):
        """
        Геттер для получения значения уровня счастья

        :return: __happiness
        :rtype: int
        """
        return self.__happiness

    def increase_happiness(self, happiness):
        """
        Метод, который повышает уровень счастья жильцов.

        :param happiness: числовой показатель, который повышает уровень счастья жильцов.
        :type happiness: int
        """
        self.__happiness += happiness

    def decrease_happiness(self):
        """
        Метод, который понижает уровень счастья жильцов.
        """
        self.__happiness -= 10

    def work_day(self):
        """
        Метод увеличивает количество денег в доме (имитирует заработок денег мужем)
        и понижает сытость объекта, который работает. Метод взаимодействует
        с объектом класса House (метод change_amount_money).
        """
        change_money = True
        self.decrease_satiety(10)
        self.house.change_amount_money(change_money)
        print('{} сегодня весь день работал.'
              'Уровень сытости понизился на 10 ед. до значения {}.'
              ' Количество денег увеличилось до значения {}.'.format(
                self.get_name(),
                self.get_satiety(),
                self.house.get_bedside_table_with_money()
              ))

    def play(self):
        """
        Метод увеличивает количество счастья объекта (имитирует игру мужа за компьютером)
        и понижает сытость объекта, который играет.
        """
        self.decrease_satiety(10)
        self.increase_happiness(20)
        print('{} сегодня целый день играл в Warcraft 3. Уровень его сытости понизился на 10 ед.'
              'до значения {}.\nУровень счастья повысился на 20 пунктов. Текущее значение счастья - {}.'.format(
                self.get_name(),
                self.get_satiety(),
                self.get_happiness()
              ))

    def caress_cat(self):
        """
        Метод увеличивает количество счастья объекта (имитирует как муж гладит кота)
        и понижает сытость объекта, который погладил кота.
        """
        self.increase_happiness(5)
        self.decrease_satiety(10)
        print('{name} погладил кота. Текущее значение счастья жильца {name} составляет {happiness}.'
              ' Уровень сытости {name} уменьшился на 10 ед. до значения {satiety}'.format(
                name=self.get_name(),
                happiness=self.get_happiness(),
                satiety = self.get_satiety()
              ))

    def is_die_of_depression(self):
        """
        Метод, который определяет не умер ли муж от депрессии (только люди).

        :return False, если муж умер и True, если муж жив
        """
        if self.get_happiness() < 10:
            print('{} умер(ла) от депрессии.'.format(self.get_name()))
            return False
        else:
            return True


class Wife(Tenant):
    """
    Класс Wife. Родитель: Tenant. Класс создает объект жена.

    Args:
        name (str): передается имя объекта
        satiety (int) передается уровень сытости объекта (значение установлено по умолчанию)
        happiness (int) передается уровень счастья объекта (значение установлено по умолчанию)

    Attributes:
        __happiness (int) уровень счастья объекта
    """
    def __init__(self, name, satiety=30, happiness=100):
        super().__init__(name, satiety)
        self.__happiness = happiness

    def get_happiness(self):
        """
        Геттер для получения значения уровня счастья

        :return: __happiness
        :rtype: int
        """
        return self.__happiness

    def increase_happiness(self, happiness):
        """
        Метод, который повышает уровень счастья жильцов.

        :param happiness: числовой показатель, который повышает уровень счастья жильцов.
        :type happiness: int
        """
        self.__happiness += happiness

    def decrease_happiness(self):
        """
        Метод, который понижает уровень счастья жильцов.
        """
        self.__happiness -= 10

    def go_to_shop(self):
        """
        Метод увеличивает количество продуктов в доме (имитирует поход жены в магазин)
        и понижает сытость объекта, который пошел за покупками. Метод взаимодействует с объектом класса House
        (методы: change_amount_of_food и change_amount_money) и изменяет их значения.
        """
        change_food = True
        change_money = False
        self.decrease_satiety(10)
        self.house.change_amount_of_food(change_food, 100)
        self.house.change_amount_money(change_money, 100)
        print('{} сходила в магазин, ее уровень сытости уменьшился на 10 ед. до значения {}.'
              ' Количество продуктов в холодильнике увеличилось до значения {},'
              ' количество денег уменьшилось до значения {}..'.format(
                self.get_name(),
                self.get_satiety(),
                self.house.get_refrigerator_with_food(),
                self.house.get_bedside_table_with_money()
              ))

    def buy_cat_food(self):
        """
        Метод увеличивает количество корма для кота в доме (имитирует поход жены в зоомагазин)
        и понижает сытость объекта, который пошел за кормом. Метод взаимодействует с объектом класса House
        (методы: change_amount_of_food_for_cat и change_amount_money) и изменяет их значения
        """
        change_food_for_cat = True
        change_money = False
        self.decrease_satiety(10)
        self.house.change_amount_of_food_for_cat(change_food_for_cat, 50)
        self.house.change_amount_money(change_money, 50)
        print('{} покупает еду коту, уровень ее сытости уменьшился на 10 ед. до значения {}.'
              ' Количества еды для кота увеличилось до значения {}.'
              ' Количество деньг уменьшилось до значения {}.'.format(
                self.get_name(),
                self.get_satiety(),
                self.house.get_food_for_cat(),
                self.house.get_bedside_table_with_money()
              ))

    def buy_coat(self):
        """
        Метод увеличивает количество счастья объекта (имитирует покупку женой шубы)
        и понижает сытость объекта, который пошел за шубой. Метод взаимодействует с объектом класса House
        (метод: change_amount_money) и изменяет его значение.
        """
        if self.house.get_bedside_table_with_money() >= 450:
            change_money = False
            self.house.change_amount_money(change_money, 350)
            self.increase_happiness(60)
            self.decrease_satiety(10)
            print('{} купила шубу. Уровень ее сытости снизился на 10 ед. до значения {}.'
                  ' Уровень счастья увеличился до значения {}.'
                  ' Количество денег уменьшилось до значения {}.'.format(
                    self.get_name(),
                    self.get_satiety(),
                    self.get_happiness(),
                    self.house.get_bedside_table_with_money()
                  ))
        else:
            self.decrease_satiety(10)
            print(' У {} недостаточно денег, поэтому она просто любовалась шубой в магазине.'
                  ' Значение сытости снизилось на 10 ед. до значения {}.'.format(
                    self.get_name(),
                    self.get_satiety()
                  ))

    def clean_up_house(self):
        """
        Метод уменьшает количество грязи в доме (имитирует уборку женой в доме)
        и понижает сытость объекта, который занимается уборкой. Метод взаимодействует с объектом класса House
        (метод: change_amount_of_dirt_in_house) и изменяет его значение.
        """
        clean_up_dirt = 100
        clean_house = True
        self.decrease_satiety(10)
        if self.house.get_dirt_in_house() < clean_up_dirt:
            clean_up_dirt = self.house.get_dirt_in_house()
        self.house.change_amount_of_dirt_in_house(clean_house, clean_up_dirt)
        print('{} убрала в доме {} единиц грязи, уровень ее сытости снизился на 10 ед. до значения {}. '
              ' Текущее значение грязи уменьшилось до значения {}.'.format(
                self.get_name(),
                self.get_satiety(),
                clean_up_dirt,
                self.house.get_dirt_in_house()
              ))

    def caress_cat(self):
        """
        Метод увеличивает количество счастья объекта (имитирует как жена гладит кота)
        и понижает сытость объекта, который погладил кота.
        """
        self.increase_happiness(5)
        self.decrease_satiety(10)
        print('{name} погладил кота. Текущее значение счастья жильца {name} составляет {happiness}.'
              ' Уровень сытости {name} уменьшился на 10 ед. до значения {satiety}.'.format(
                name=self.get_name(),
                happiness=self.get_happiness(),
                satiety = self.get_satiety()
              ))

    def is_die_of_depression(self):
        """
        Метод, который определяет не умерла ли жена от депрессии (только люди).

        :return False, если жена умерла и True, если жена жива
        """
        if self.get_happiness() < 10:
            print('{} умер(ла) от депрессии.'.format(self.get_name()))
            return False
        else:
            return True


class Cat(Tenant):
    """
    Класс Cat. Родитель: Tenant. Класс создает объект кот.

    Args:
        name (str): передается имя объекта
        satiety (int) передается уровень сытости объекта (значение установлено по умолчанию)
    """

    def __init__(self, name, satiety=30):
        super().__init__(name, satiety)

    def eat(self):
        """
        Метод, который создает взаимодействие объекта кот с объектом класса House
        (метод: change_amount_of_food_for_cat), направлен на повышение уровня сытости кота (имитирует как кот ест).
        """
        change_food_for_cat = False
        self.increase_satiety(20)
        self.house.change_amount_of_food_for_cat(change_food_for_cat, 10)
        print('{} съел(а) {} единиц еды. Уровень сытости поднялся на 20 ед. до значения {},'
              ' количество еды для кота уменьшилось на 10 ед. до значения {}.'.format(
                self.get_name(),
                20,
                self.get_satiety(),
                self.house.get_food_for_cat()
              ))

    def sleep(self):
        """
        Метод, которы имитирует как кот спит. Понижает его уровень сытости
        """
        self.decrease_satiety(10)
        print('Кот {} целый день спал. Уровень его сытости снизился на 10 ед. до значения {}.'.format(
            self.get_name(),
            self.get_satiety(),

        ))

    def tear_wallpaper(self):
        """
        Метод, которы имитирует как кот дерет обои. Понижает его уровень сытости и повышает уровень грязи в доме.
        Взаимодействует с объектом класса House (метод: change_amount_of_dirt_in_house).
        """
        self.house.change_amount_of_dirt_in_house()
        self.decrease_satiety(10)
        print('Коту {} было скучно и он хорошенько подрал обои,'
              ' уровень его сытости снизился на 10 ед., текущее значение - {}.'.format(
                self.get_name(),
                self.get_satiety()
              ))

 
 ****************************************
 
 import random
import Life_family


def live_life(man, woman, pet):
    """
    Функция live_life имитирует жизнь семьи в течение года.

    Args:
        man (class Husband): объект класса Husband
        woman (class Wife): объект класса Wife
        pet (class Cat): объект класса Cat
    """
    counter_days = 0
    defeat = False

    while counter_days != 365:
        counter_days += 1
        print('\n\t\t\t\t\t\tДень {}\n'.format(counter_days))
        man.house.change_amount_of_dirt_in_house()

        tenant = random.choice([man, woman, pet])

        if not tenant.is_live():
            defeat = True
            break
        elif not isinstance(tenant, Life_family.Cat) and not tenant.is_die_of_depression():
            defeat = True
            break
        else:
            print('Слава богу, сегодня все живы. Жизнь продолжается.')

        if man.house.get_dirt_in_house() >= 90:
            woman.decrease_happiness()
            man.decrease_happiness()
            print('В доме очень грязно! Значение счастья жильцов снизилось на 10 ед. Текущее значение {} - {}.'
                  ' Текущее значение {} - {}.'.format(
                    man.get_name(),
                    man.get_happiness(),
                    woman.get_name(),
                    woman.get_happiness()
                  ))

        if isinstance(tenant, Life_family.Cat):
            if man.house.get_food_for_cat() >= 20:
                cat.eat()
            elif isinstance(tenant, Life_family.Cat):
                if random.randint(1, 2) == 1:
                    tenant.tear_wallpaper()
                else:
                    tenant.sleep()

        elif isinstance(tenant, Life_family.Husband):
            if man.get_satiety() < 20 and man.house.get_refrigerator_with_food() >= 30:
                man.eat()
            elif man.house.get_bedside_table_with_money() <= 150:
                man.work_day()
            elif man.get_happiness() <= 50:
                man.play()
            elif man.get_happiness() <= 40:
                man.caress_cat()
            elif random.randint(1, 2) == 1:
                man.play()
            else:
                man.work_day()

        elif isinstance(tenant, Life_family.Wife):
            if woman.get_satiety() < 20 and man.house.get_refrigerator_with_food() >= 30:
                woman.eat()
            elif man.house.get_refrigerator_with_food() <= 60 and man.house.get_bedside_table_with_money() >= 100:
                woman.go_to_shop()
            elif man.house.get_dirt_in_house() >= 50:
                woman.clean_up_house()
            elif man.house.get_food_for_cat() <= 20:
                woman.buy_cat_food()
            elif woman.get_happiness() <= 50:
                woman.caress_cat()
            elif man.house.get_bedside_table_with_money() >= 450:
                woman.buy_coat()
            elif random.randint(1, 2) == 1:
                woman.caress_cat()
            elif random.randint(1, 2) == 2:
                woman.eat()
            else:
                woman.go_to_shop()

    if defeat:
        print('\nК сожалению, семья не справилась с житейскими испытаниями.\n')
    else:
        print('\nСемья справилась с вызовами жизни.\n')

    print('Итоги:\n'
          'Заработано денег: {};\n'
          'Съедено продуктов: {};\n'
          'Съедено кошачьего корма: {};\n'
          'Куплено шуб: {}.'.format(
            man.house.get_earned_money(),
            man.house.get_food_eaten(),
            man.house.get_cat_food_eaten(),
            man.house.get_bought_coat()
          ))


husband = Life_family.Husband(name='Павел')
wife = Life_family.Wife(name='Виктория')
cat = Life_family.Cat(name='Барсик')

live_life(husband, wife, cat)






 
 ****************************************
 
 
class InputError(Exception):
    """
    Класс InputError. Родитель - Exception. Создан для вызова исключения InputError
    """
    pass


class Stack:
    """Класс Stack, который создает объект - стек вызовов

    __stack (list): список, куда будут помещаться задачи пользователя
    """
    __stack = list()

    def get_stack(self):
        """
        Геттер для получения списка stack

        :return: __stack
        :rtype: list
        """
        return self.__stack

    def add_task(self, new_task):
        """
        Метод для добавления задач пользователя в стек вызовов с последующей их сортировкой
        по установленному приоритету

        :param new_task: описание задачи (str) и ее приоритет (int)
        :type  new_task: list
        """
        for index, i_elem in enumerate(self.__stack):
            if new_task[0] == i_elem[0]:
                common_action = '; '.join((i_elem[1], new_task[1]))
                del new_task[1]
                del self.__stack[index]
                new_task.append(common_action)
        self.__stack.append(new_task)
        for index_max_priority in range(len(self.__stack)):
            for index_cur_priority in range(index_max_priority + 1, len(self.__stack)):
                if self.__stack[index_max_priority][0] > self.__stack[index_cur_priority][0]:
                    self.__stack[index_max_priority], self.__stack[index_cur_priority] = \
                        self.__stack[index_cur_priority], self.__stack[index_max_priority]

    def delete_task(self, number_tasks):
        """
        Метод для удаления задач пользователя из стека вызовов

        :param number_tasks: количество задач, которые необходимо удалить
        :type  number_tasks: int
        """
        for number in range(1, number_tasks + 1):
            print('Задача(и) "{}" принудительно завершила(и) свою работу.'.format(
                ' '.join((str(self.__stack[0][0]), self.__stack[0][1]))))
            del self.__stack[0]


class TaskManager:
    """Класс TaskManager, который создает диспетчер задач

    Attributes:
        __new_task (str): атрибут строка
        __priority (int): атрибут целое число
        stack (Stack) объект класса Stack
    """
    stack = Stack()
    __new_task = str
    __priority = int

    def new_task(self, new_task, priority):
        """
        Метод для инициализации новой задачи для последующего добавления ее в стек вызовов

        :param new_task: описание задачи
        :type new_task: str

        :param priority: приоритет задачи
        :type priority: int
        """
        self.__new_task = new_task
        self.__priority = priority
        Stack.add_task(self.stack, [self.__priority, self.__new_task])

    def init_delete_task(self):
        """
        Метод для инициализации удаления задач из стека вызовов

        :raise InputError (если вводится число, которое больше чем количество задач в
        стеке вызовов то вызывается исключение)
        :except ValueError (если вводится не числовое значение то вызывается исключение)
        """
        while True:
            print('\nСколько задач должно завершить работу: ', end='')
            try:
                number_tasks = int(input())
                if number_tasks > len(Stack.get_stack(self.stack)):
                    raise InputError('\nОшибка ввода: в диспетчере задач нет столько активных программ.\n')
                else:
                    Stack.delete_task(self.stack, number_tasks)
            except ValueError:
                print('\nОшибка ввода: необходимо вводить цифровые значения.\n')
            except InputError as exc:
                print(exc)
            else:
                break

    def display_result(self):
        """
        Метод для отображения результатов работы программы.
        """
        print('\nРезультат:')
        if not Stack.get_stack(self.stack):
            print('В диспетчере задача нет активных программ.')
        else:
            for i_elem in Stack.get_stack(self.stack):
                print(' '.join((str(i_elem[0]), i_elem[1])))


manager = TaskManager()
manager.new_task(new_task="сделать уборку", priority=4)
manager.new_task(new_task="помыть посуду", priority=4)
manager.new_task(new_task="отдохнуть", priority=1)
manager.new_task(new_task="поесть", priority=2)
manager.new_task(new_task="сдать дз", priority=2)
manager.display_result()
manager.init_delete_task()
manager.display_result()

 
 ****************************************
 
 from collections.abc import Iterable


# Вариант класс-итератор.
class SquaringIteration:
    """ Класс-итератор создает объект-итератор, возвращающий квадрат числа из последовательности от 1 до N.

    Arguments:
        num_n (int): число N

    Attributes:
        self.__num_n (int): число N
        self.__counter (int): счетчик N
    """

    def __init__(self, num_n: int) -> None:
        """Инициализирует экземпляр класса.

        Args:
            num_n: передаваемое значение N
        """
        self.__num_n = num_n
        self.__counter = 1

    def __iter__(self):
        """Создает итератор.

        :return: self
        """
        return self

    def __next__(self) -> int:
        """Возвращает следующий элемент последовательности.

        :return: self.__counter
        :raise StopIteration: вызывает исключение в случае, если элементы последовательности заканчиваются
        """
        if self.__counter <= self.__num_n:
            self.__counter += 1
            return (self.__counter - 1) ** 2
        raise StopIteration


number_n = int(input('Введите натуральное число N: '))
squaring = SquaringIteration(number_n)

for num in squaring:
    print(num, end=' ')

print()


# Вариант функция-генератор.
def squaring_generation(num_n: int) -> Iterable[int]:
    """
    Возвращает квадрат числа для каждого значения из последовательности от 1 до числа N.

    :param num_n: крайнее число в последовательности.
    :return: counter (int)
    """

    counter = 1

    while counter <= num_n:
        yield counter ** 2
        counter += 1


squaring_2 = squaring_generation(number_n)

for num in squaring_2:
    print(num, end=' ')

print()

# Вариант генераторное выражение.
squaring_3 = (i_num ** 2 for i_num in range(1, number_n + 1))

for num in squaring_3:
    print(num, end=' ')

 
 ****************************************
 
 from collections.abc import Iterable


def calculate_products_gen(lst_1: list[int], lst_2: [int], find: int) -> Iterable[tuple]:
    """ Возвращает произведение элементов из списков 1 и 2

    Args:

        lst_1: первый список элементов
        lst_2: второй список элементов
        find: искомое произведение

    :yield: Iterable[tuple]
    """
    for x in lst_1:
        for y in lst_2:
            result = x * y
            yield x, y, result
            if result == find:
                print('Found!!!')
                return


list_1 = [2, 5, 7, 10]
list_2 = [3, 8, 4, 9]
to_find = 56

products_generation = calculate_products_gen(list_1, list_2, to_find)

for i_product in products_generation:
    print(*i_product)

 
 ****************************************
 
 from collections.abc import Iterable
import os


def gen_files_path(cur_path: str, search_directory: str) -> Iterable[str]:
    """Возвращает абсолютные пути файлов, находящиеся в указанном пользователем каталоге

    Args:
        cur_path: директория по умолчанию
        search_directory: искомый каталог

    :yields: Iterable[str]
    """
    try:
        for i_elem in os.listdir(cur_path):
            updated_path = os.path.join(cur_path, i_elem)
            if i_elem == search_directory:
                for address, dirs, files in os.walk(updated_path):
                    for name in files:
                        yield os.path.join(address, name)
            else:
                if os.path.isdir(updated_path):
                    yield from gen_files_path(updated_path, search_directory)
    except PermissionError:
        pass


strings_path = list()
path = os.path.abspath(os.path.sep)
directory = input('Введите название каталога для поиска: ')

generation_search_path_file = gen_files_path(path, directory)

print('\nАбсолютные пути к файлам, содержащиеся в каталоге "{}":\n'.format(directory))

for file_path in generation_search_path_file:
    print(file_path)
    strings_path.append(file_path)


if not strings_path:
    print('\n<--------------------------------------------------------------------------->\n'
          '\nДанный каталог либо пуст, либо его нет в указанной по умолчанию директории.')












 
 ****************************************
 
 from collections.abc import Iterable


class QHofstadter:
    """ Класс-итератор создает объект-итератор, генерирующий последовательность Хофштадтера
     в диапазоне от 1 до 2 числа списка.

     __q_seq_dict (dict): словарь для хранения значений последовательности Хофштадтера

       Arguments:
           lst (int): список из двух чисел (начало и конец диапазона последовательности)

       Attributes:
           self.__lst (list): список из двух чисел
           self.__lst_copy (list):копия списка lst
       """
    __q_seq_dict = dict()

    def __init__(self, lst: list[int]) -> None:
        """Инициализирует экземпляр класса.

        Args:
            lst: передаваемый список значений
        """
        self.__lst = lst
        self.__lst_copy = lst[:]

    def __iter__(self):
        """Создает итератор.

        :return: self
        """
        return self

    def generate_qhofstadter_seq(self) -> None:
        """Генерирует последовательность Хофштадтера от 1 элемента последовательности и значения 2 числа списка lst.

        :raise: вызывает исключение StopIteration (завершение работы программы) в случае,
         если 1 и 2 число списка lst равны значениям "1" и "2" соответственно.
        """
        if self.__lst[0] == 1 and self.__lst[1] == 2:
            print('Программа завершила свою работу.')
            raise StopIteration
        elif self.__lst[0] == 0 or self.__lst[0] > self.__lst[1]:
            raise InputNumberError('Ошибка! Список составлен из неподходящих чисел:'
                                   ' первое число должно быть больше нуля,'
                                   ' второе число должно быть больше первого.')
        else:
            for num in range(1, self.__lst[1] + 1):
                if num == 1 or num == 2:
                    self.__q_seq_dict[('Q', num)] = 1
                elif num == 3:
                    self.__q_seq_dict[('Q', num)] = self.__q_seq_dict[('Q', num - 1)]\
                                                    + self.__q_seq_dict[('Q', num - 1)]
                else:
                    self.__q_seq_dict[('Q', num)] = self.__q_seq_dict[('Q', (num - self.__q_seq_dict[('Q', num - 1)]))]\
                                                  + self.__q_seq_dict[('Q', (num - self.__q_seq_dict[('Q', num - 2)]))]

    def __next__(self) -> Iterable[int]:
        """Возвращает следующий элемент последовательности.

        :return: self.__q_seq_dict
        :raise StopIteration: вызывает исключение в случае, если элементы последовательности заканчиваются
        """
        self.generate_qhofstadter_seq()
        while self.__lst_copy[0] <= self.__lst_copy[1]:
            self.__lst_copy[0] += 1
            return self.__q_seq_dict[('Q', (self.__lst_copy[0] - 1))]
        raise StopIteration


class InputNumberError(Exception):
    """ Класс-исключение создает исключение в случае, если в список lst подаются некорректные значение: lst[0] = 0,
    lst[0] > lst[1]"""
    pass


gen_qhofstadte_seq = QHofstadter(lst=[1, 20])

for i_num in gen_qhofstadte_seq:
    print(i_num, end=' ')

 
 ****************************************
 
 number_synonyms = int(input('Введите количество пар слов: '))

synonyms_dict = dict()

for num in range(1, number_synonyms + 1):
    pair_synonyms = input('{} пара (введите через пробел тире пробел): '.format(num)).split(' - ')
    synonyms_dict[pair_synonyms[0]] = ''.join(pair_synonyms[1])

# print()

while True:
    word = input('Введите слово: ')
    flag = False

    for key in synonyms_dict:
        if word.lower() in synonyms_dict[key].lower():
            print('Синоним: ', key)
            flag = True
            break
        elif word.lower() == key.lower():
            print('Синоним: ', synonyms_dict[key])
            flag = True
            break
        else:
            print('Такого слова нет в словаре')
            break

    if flag:
        break
 
 ****************************************
 
 import random

origin_list = [random.randint(0, 10) for _ in range(10)]

print('Оригинальный список:', origin_list)

result_part_one = [
    elem
    for index, elem in enumerate(origin_list)
    if index % 2 == 0
]

result_part_two = [
    elem
    for index, elem in enumerate(origin_list)
    if index % 2 != 0
]

total_result = [(result_part_one[index], result_part_two[index]) for index in range(5)]

print('Новый список:', total_result)

# Как вариант, можно использовать функцию zip и распаковать циклом for:
# result = zip(new_list_part_one, new_list_part_two)
# for pair in result:
#     print(pair)
 
 ****************************************
 
 from collections.abc import Iterable
import os


def generate_number_str(directory_path: str) -> Iterable[tuple[str, int]]:
    """Возвращает имя файла с расширением .py и количество его строк кода (кроме пустых и закомментированных строк)

    Args:
        directory_path (str): абсолютный путь каталога, в котором будет осуществляться поиск файлов.

    :yield: Iterable[tuple[str, int]]
    """
    counter_str = 0

    for i_elem in os.listdir(directory_path):
        path = os.path.join(directory_path, i_elem)
        if os.path.isfile(path) and i_elem.endswith('.py'):
            with open(path, 'r', encoding='UTF-8') as file_python:
                for i_line in file_python:
                    if i_line.startswith('#'):
                        continue
                    elif i_line == '\n':
                        continue
                    else:
                        counter_str += 1
                else:
                    yield i_elem, counter_str
                    counter_str = 0
        elif os.path.isdir(path):                           # Эти две строки нужны в случае, если
            yield from generate_number_str(path)            # в каталоге есть подкаталоги с питоновскими файлами.


dir_name = '05_str_count'
dir_path = os.path.abspath(os.path.join('..', dir_name))
total_counter_str = 0

gen_number_str = generate_number_str(dir_path)

for name_file, counter_string in gen_number_str:
    print('Имя файла: {0}, количество строк в нем: {1}'.format(name_file, counter_string))
    total_counter_str += counter_string

print('\nОбщее количество строк во всех файлах папки {0}: {1}'.format(dir_name, total_counter_str))

 
 ****************************************
 
 from collections.abc import Iterable


class Junction:
    """Класс Junction создает объект узел в качестве слотов для хранения данных.

       Arguments:
           junction (int): передаваемые данные

       Attributes:
           self.junction (int, str): текущий узел
           self.next_junction (int, str): следующий узел
    """
    def __init__(self, junction=None) -> None:
        """Инициализирует экземпляр класса.

        Args:
            junction: передаваемый значение (int)
        """
        self.junction = junction
        self.next_junction = None


class LinkedList:
    """Класс LinkedList создает объект-направление движения по списку.

       Attributes:
           self.head: начало списка (изначальное значение None)
    """

    def __init__(self) -> None:
        """Инициализирует экземпляр класса."""
        self.head = None

    def generate_elem(self) -> Iterable[int]:
        """Генерирует элементы списка.

        :yield: Iterable[int]
        """
        iter_elem = self.head
        while iter_elem is not None:
            yield iter_elem.junction
            iter_elem = iter_elem.next_junction

    def append(self, new_data: int) -> None:
        """Добавляет в список новые элементы.

        :param new_data: значение, добавляемое в узел

        :return: None
        """
        new_junction = Junction(new_data)
        if self.head is None:
            self.head = new_junction
            return
        last_junction = self.head
        while last_junction.next_junction:
            last_junction = last_junction.next_junction
        last_junction.next_junction = new_junction

    def get(self, index: int) -> int or str:
        """Получение элемента по индексу.

        :param index: индекс для поиска элемента в списке

        :return: last_junction.junction (int); str (сообщение об отсутствии элемента)
        """
        last_junction = self.head
        junction_index = 0
        while junction_index <= index:
            if junction_index == index:
                return last_junction.junction
            junction_index += 1
            last_junction = last_junction.next_junction
            if last_junction is None:
                return '<элемента с таким индексом нет>'

    def remove(self, remove_elem: int) -> None:
        """Получение элемента по индексу.

        :param remove_elem: индекс для удаления элемента из списка

        :return: None
        :raise IndexError: в случае если значение индекса выходит за границы списка, то вызывается исключение
        """
        head_junction = self.head
        last_junction = None
        junction_index = 0
        if head_junction is not None:
            if junction_index == remove_elem:
                self.head = head_junction.next_junction
                return
        while head_junction is not None:
            if junction_index == remove_elem:
                break
            last_junction = head_junction
            head_junction = head_junction.next_junction
            junction_index += 1
        if head_junction is None:
            raise IndexError('Ошибка удаления элемента: Вы вышли за границы списка.')
        last_junction.next_junction = head_junction.next_junction

    def __str__(self) -> str:
        """Возвращает строку-список элементов

        :return: result (str)
        """
        current_junction = self.head
        result = '['
        while current_junction is not None:
            result += ''.join(str(current_junction.junction) + ' ')
            current_junction = current_junction.next_junction
        result = result[:len(result) - 1]
        result += ']'
        return result


my_list = LinkedList()
my_list.append(10)
my_list.append(20)
my_list.append(30)

print('Текущий список:', my_list)
print('Получение третьего элемента:', my_list.get(2))
print('Удаление второго элемента.')
my_list.remove(1)
print('Новый список:', my_list)
generation_values = my_list.generate_elem()

print('Итерирование по списку с помощью цикла for.')
for i_elem in generation_values:
    print(i_elem)


 
 ****************************************
 
 from typing import Callable, Any
import functools


def worry(func: Callable) -> Callable:
    """Декоратор, выводящий две строки текста перед выводом результата работы функции."""

    @functools.wraps(func)
    def wrapped_func(*args, **kwargs) -> Any:
        print('Как дела? Хорошо.')
        print('А у меня не очень! Ладно, держи свою функцию.')
        result = func(*args, **kwargs)
        return result

    return wrapped_func


@worry
def test_1() -> None:
    """Функция, выводящая строку текста."""

    print('<Тут что-то происходит...>\n')


@worry
def test_2(number: int) -> int:
    """
    Функция, возвращающая квадратную степень переданного в нее числа.

    :param number: переданное число.
    :return: переданное число, возведенное в квадратную степень
    """

    return number ** 2


@worry
def test_3() -> list[int]:
    """
    Функция, возвращающая список четных чисел от 0 до 10.

    :return: список четных чисел.
    """

    return [x for x in range(11) if x % 2 == 0]


test_1()
print(test_2(2), '\n')
print(test_3())

 
 ****************************************
 
 from typing import Callable, Any
import functools
import time


def sleep(func: Callable) -> Callable:
    """Декоратор, осуществляющий задержку начала работы функции на 3 секунды."""

    @functools.wraps(func)
    def wrapped_func(*args, **kwargs) -> Any:
        time.sleep(3)
        result = func(*args, **kwargs)
        return result

    return wrapped_func


@sleep
def calculate_even_nums() -> list[int]:
    """
    Функция, возвращающая список четных чисел от 0 до 10.

    :return: список четных чисел.
    """

    return [num for num in range(11) if num % 2 == 0]


print(calculate_even_nums())


 
 ****************************************
 
 from typing import Callable, Any
from datetime import datetime

import functools


def do_logging(func: Callable) -> Callable:
    """Декоратор, совершающий логирование функции,
     а также выводящий на экран название функции и ее документацию.
     """

    @functools.wraps(func)
    def wrapped_func(*args, **kwargs) -> Any:
        print('Название функции: {name}.\nЕе документация: {doc}'.format(
            name=func.__name__,
            doc=func.__doc__
        ))
        result = func(*args, **kwargs)
        if isinstance(result, Exception):
            with open('function_errors.log', 'a') as file_log:
                file_log.write(func.__name__ + ': Error: ' + str(type(result))
                               + ' ' + str(datetime.now()) + '\n')
            return 'Во время работы функции произошла ошибка. Она записана в файл function_errors.log.'
        else:
            return result

    return wrapped_func


@do_logging
def calculate_squares(number: int) -> int:
    """
    Функция, возвращающая квадратную степень переданного в нее числа.

    :param number: переданное число.
    :return: переданное число, возведенное в квадратную степень
    """

    return number ** 2


@do_logging
def divide_number(number: int) -> Any:
    """
    Функция, возвращающая частное от деления переданного числа на делитель.

    :param number: переданное число
    :return: частное.
    :except ZeroDivisionError: В случае если происходит деление числа на ноль, то вызывается исключение.
    """
    try:
        result = number / 0

        return result
    except ZeroDivisionError as exc:
        return exc


@do_logging
def calculate_even_nums() -> list[int]:
    """
    Функция, возвращающая список четных чисел от 0 до 10.

    :return: список четных чисел.
    """

    return [num for num in range(11) if num % 2 == 0]


@do_logging
def add_numbers(number: int) -> Any:
    """
    Функция, возвращающая сумму переданного числа и числа "4".

    :param number: переданное число
    :return: сумма чисел.
    :except TypeError: В случае если происходит сложение разных типов данных, вызывается исключение.
    """

    try:
        result = number + '4'

        return result
    except TypeError as exc:
        return exc


print('Результат работы функции: {} \n'.format(calculate_squares(2)))
print('Результат работы функции: {} \n'.format(divide_number(3)))
print('Результат работы функции: {} \n'.format(calculate_even_nums()))
print('Результат работы функции: {} \n'.format(add_numbers(4)))

 
 ****************************************
 
 from typing import Callable, Optional, Any
import functools


def use_debug(func: Callable) -> Callable:
    """Декоратор, выводящий две строки (имя функции (вместе со всеми передаваемыми аргументами)
     и значение, которое она возвращает) перед выводом результата работы переданной функции.
     """
    @functools.wraps(func)
    def wrapped_func(*args, **kwargs) -> None:
        if len(args) > 1 and not kwargs:
            print('\nВызывается {0}{1}'.format(
                func.__name__, args))
        elif not kwargs:
            print('\nВызывается {0}({1})'.format(func.__name__, repr(*args)))
        elif args and kwargs:
            print('\nВызывается {0}({1}, '.format(func.__name__, repr(*args)) +
                  ''.join([f'{key}={repr(value)})'
                           for key, value in kwargs.items()
                           if key == 'age']))
        elif not args:
            print('\nВызывается {0}('.format(func.__name__) +
                  ', '.join([f'{key}={repr(value)})'
                             if key == 'age' else repr(value)
                             for key, value in kwargs.items()]))

        print('{0} вернула значение {1}'.format(repr(func.__name__), repr(func(*args, **kwargs))))
        print(func(*args, **kwargs))

    return wrapped_func


@use_debug
def greeting(name: str, age: Optional[int] = None) -> str:
    """Функция, возвращающая строку с переданными аргументами.

    :param name: переданное имя.
    :param age: переданный возраст

    :return: строка с переданными аргументами
    """
    if age:
        return "Ого, {name}! Тебе уже {age} лет, ты быстро растёшь!".format(name=name, age=age)
    else:
        return "Привет, {name}!".format(name=name)


greeting('Tom')
greeting('Anna', 23)
greeting("Миша", age=100)
greeting(name="Катя", age=16)

 
 ****************************************
 
 from typing import Callable, Any
import functools


def counter(func: Callable, counter_dict: dict[str, int] = None) -> Callable:
    """Декоратор, совершающий подсчет количества вызовов переданной в него функции.

    :param: counter_dict словарь-счетчик (по умолчанию его значение None)
    """

    if counter_dict is None:
        counter_dict = {'counter': 0}

    @functools.wraps(func)
    def wrapped_func(*args, **kwargs) -> Any:
        counter_dict['counter'] += 1
        print('Функция вызывалась {} раз(а)'.format(*counter_dict.values()))
        result = func(*args, **kwargs)
        return 'Результат работы функции: {}'.format(result)

    return wrapped_func


@counter
def add_numbers(number: int) -> int:
    """
    Функция, возвращающая сумму переданного числа и числа "1".

    :param number: переданное число
    :return: сумма чисел.
    """

    result = number + 1
    return result


@counter
def calculate_squares(number: int) -> int:
    """
    Функция, возвращающая квадратную степень переданного в нее числа.

    :param number: переданное число.
    :return: переданное число, возведенное в квадратную степень
    """

    return number ** 2


print('Вызов функции {}'.format(add_numbers.__name__))

for num in range(1, 11):
    print(add_numbers(num), '\n')

print('\nВызов функции {}'.format(calculate_squares.__name__))

for num in range(1, 11):
    print(calculate_squares(num), '\n')

 
 ****************************************
 
 import os
from typing import Optional, Any


class File:
    """Класс контент-менеджер для работы с файлами. Осуществляет создание, открытие, запись, чтение и закрытие файла.

    Args:
        file_name: имя файла
        mode: режим работы с файлом

    Attributes:
        self.__file_name: имя файла
        self.__mode: режим работы с файлом
        self.__file: файл, с котором будет осуществляться работа (по умолчанию None)
    """

    def __init__(self, file_name: str, mode: str) -> None:
        """Метод для инициализации экземпляра класса"""
        self.__file_name = file_name
        self.__mode = mode
        self.__file = None

    @property
    def mode(self) -> str:
        """Геттер для получения режима работы с файлом

        :return: режим работы с файлом
        """
        return self.__mode

    def __enter__(self) -> Optional[Any]:
        """Магический метод для открытия файла

        :return: файл в соответствующем режиме работы или None в случае вызова исключения.
        :except PermissionError: в случае если к файлу нет подступа, то вызывается исключение.
        :except IsADirectoryError: в случае если файл является директорией, то вызывается исключение.
        """
        try:
            file_path = os.path.abspath(self.__file_name)
            if os.path.isdir(file_path):     # Эти две строки кода нужны на случай, если вдруг (что мало вероятно:) )
                raise IsADirectoryError      # у пользователя будет директория с именем, заканчивающимся на '.txt'
            elif not os.path.exists(file_path) and self.__mode == 'r':
                print('Такого файла нет. Он создан в режиме записи.')
                self.__file = open(file_path, 'w', encoding='UTF-8')
                return self.__file
            else:
                self.__file = open(file_path, self.__mode, encoding='UTF-8')
                return self.__file
        except (PermissionError, IsADirectoryError):
            return None

    def __exit__(self, exc_type, exc_val, exc_tb) -> Optional[Any]:
        """Магический метод, который либо закрывает файл в случае, если тот был открыт, либо возвращает True,
         если файл не был открыт.

         :return: True, None
         """
        if self.__file is None:
            return True
        self.__file.close()


def work_with_file(name: str, mode: str) -> None:
    """Функция, осуществляющая чтение или запись файла.

    :param:
        name: имя файла
        mode: режим работы с файлом
    """
    with File(name, mode) as file:

        if file is None:
            print('Ошибка при работе с файлом! Либо вместо файла указана директория, либо к файлу нет доступа'
                  ' (нужны права администратора).')
        elif file.mode == 'r':
            result = file.read()
            print('Текст находящийся в файле: {}.'.format(repr(result)))
        else:
            text = input('Введите текст для записи в файл: ')
            file.write(text)
            print('Текст успешно записан.')


def input_date() -> tuple[str, str]:
    """Функция, возвращающая введенное пользователем имя файла и режим работы с ним."""

    print('Введите имя файла:')
    name_of_file = input('>>> ')
    if not name_of_file.endswith('.txt'):
        name_of_file = ''.join((name_of_file, '.txt'))

    print('Выберите режим работы с файлом (r - чтение, w - запись информации):')
    while True:
        mode_of_work = input('>>> ').lower()

        if mode_of_work != 'r' and mode_of_work != 'w':
            print('Ошибка ввода! Введите либо "r" или "w".')
        else:
            break

    return name_of_file, mode_of_work


name_of_document, mode_of_operation = input_date()
work_with_file(name_of_document, mode_of_operation)



 
 ****************************************
 
 from my_math_module import MyMath

res_1 = MyMath.calculate_circle_len(radius=5)
res_2 = MyMath.calculate_circle_sq(radius=6)
res_3 = MyMath.calculate_cube_volume(edge_len=3)
res_4 = MyMath.calculate_sphere_surface_sq(radius=4)
res_5 = MyMath.calculate_cylinder_full_surface_sq(radius=4, altitude=8)


print('Длинна окружности =', res_1)
print('Площадь окружности =', res_2)
print('Объем куба =', res_3)
print('Площадь поверхности сферы =', res_4)
print('Полная площадь поверхности цилиндра =', res_5)

 
 ****************************************
 
 from math import pi


class MyMath:
    """Класс, содержащий методы для различных математических вычислений, связанных с фигурами."""

    @classmethod
    def calculate_circle_len(cls, radius: float) -> float:
        """Метод для вычисления длины окружности."""
        result = 2 * pi * radius
        return round(result, 2)

    @classmethod
    def calculate_circle_sq(cls, radius: float) -> float:
        """Метод для вычисления площади окружности."""
        result = pi * radius ** 2
        return round(result, 2)

    @classmethod
    def calculate_cube_volume(cls, edge_len: float) -> float:
        """Метод для вычисления объема куба."""
        result = edge_len ** 3
        return round(result, 2)

    @classmethod
    def calculate_sphere_surface_sq(cls, radius: float) -> float:
        """Метод для вычисления площади поверхности сферы."""
        result = pi * 4 * radius ** 2
        return round(result, 2)

    @classmethod
    def calculate_cylinder_full_surface_sq(cls, radius: float, altitude: float) -> float:
        """Метод для вычисления полной площади поверхности цилиндра."""
        result = (2 * pi * radius * altitude) + (2 * pi * radius ** 2)
        return round(result, 2)



 
 ****************************************
 
 import my_models

square = my_models.Square(5)
print('Модель квадрат:\nПериметр квадрата = {0} см.\n'
      'Площадь квадрата = {1} см.'.format(
        square.calculate_perimeter(),
        square.calculate_area()
        ))

triangle = my_models.Triangle(6, 4)
print('\nМодель треугольник:\nПериметр треугольника = {0} см.\n'
      'Площадь треугольника = {1} см.'.format(
        triangle.calculate_perimeter(),
        triangle.calculate_area()
        ))

cube = my_models.Cube(4)
print('\nМодель куб:\nОтдельная поверхность куба: {0}\n'
      'Куб состоит из следующих 2D фигур: {1}.\n'
      'Площадь всей поверхности куба = {2} см.'.format(
        cube.surface,
        ', '.join([''.join(str(num)) for num in cube.surfaces]),
        cube.calculate_all_area(cube.surfaces)
        ))

pyramid = my_models.Pyramid(6, 4, 4)

print('\nМодель пирамида:\nОтдельные поверхность пирамиды: {0}и и {1}\n'
      'Пирамида состоит из следующих 2D фигур: {2}.\n'
      'Площадь всей поверхности пирамиды = {3} см.'.format(
        pyramid.surface_triangle,
        pyramid.surface_square,
        ', '.join([str(i_elem) for i_elem in pyramid.surfaces]),
        pyramid.calculate_all_area(pyramid.surfaces)
        ))


 
 ****************************************
 
 from abc import ABC, abstractmethod
from math import sqrt
from typing import Optional, Any


class Figura(ABC):
    """Абстрактный базовый класс для создания 2D геометрических фигур (квадрат и треугольник)

    Args:
        name_of_figure название фигуры (изначально None, в дочерних классах будет переопределен в тип str)

    Attributes:
        _name_of_figure название фигуры
    """

    def __init__(self, name_of_figure: Optional[Any] = None) -> None:
        """Магический метод для инициализации объекта фигура.

        :param:
            name_of_figure имя фигуры (изначально None)
        """
        self._name_of_figure = name_of_figure

    def __str__(self) -> Optional[Any]:
        """Магический метод для отображения названия фигуры.

        :return: название фигуры
        """
        return self._name_of_figure

    @abstractmethod
    def calculate_perimeter(self) -> None:
        """Абстрактный метод для вычисления периметра фигуры."""
        pass

    @abstractmethod
    def calculate_area(self) -> None:
        """Абстрактный метод для вычисления площади фигуры."""
        pass


class Square(Figura):
    """Дочерний класс. Родитель абстрактный класс Figura. Инициализирует объект класса Square (квадрат).

    Args:
        side: длинна стороны квадрата

    Attributes:
        __side: длинна стороны квадрата
    """

    def __init__(self, side: float) -> None:
        """Магический метод для инициализации объекта квадрат. Содержит наследование (атрибут название фигуры) от
         родительского класса.

        :param:
            side: длинна стороны квадрата
        """
        super().__init__('квадрат')
        self.side = side

    @property
    def side(self) -> float:
        """Геттер возвращает длинную стороны квадрата.

        :return: длину стороны квадрата
        """
        return self.__side

    @side.setter
    def side(self, side: float) -> None:
        """Сеттер для проверки передаваемого значения side.

        :param:
            side длина стороны квадрата

        :raise BaseException: В случае, если передаваемое значение меньше либо равно нулю, то вызывается исключение.
        """
        if side > 0:
            self.__side = side
        else:
            raise BaseException('Передаваемые значения должны быть больше нуля.')

    def calculate_perimeter(self) -> float:
        """Переопределенный метод для вычисления периметра квадрата.

        :return: периметр квадрата
        """
        return self.side * 4

    def calculate_area(self) -> float:
        """Переопределенный метод для вычисления площади квадрата.

        :return: площадь квадрата
        """
        return self.side ** 2


class Triangle(Figura):
    """Дочерний класс. Родитель  абстрактный класс Figura. Инициализирует объект класса Triangle (треугольник).

    Args:
        base_length: длинна основания треугольника
        altitude: высота треугольника

    Attributes:
        __base_length: длинна основания треугольника
        __altitude: высота треугольника
    """

    def __init__(self, base_length: float, altitude: float) -> None:
        """Магический метод для инициализации объекта треугольник. Содержит наследование (атрибут название фигуры)
        от родительского класса.

        :param:
            base_length: длинна основания треугольника
            altitude: высота треугольника
        """
        super().__init__('треугольник')
        self.base_length = base_length
        self.altitude = altitude

    @property
    def base_length(self) -> float:
        """Геттер возвращает длинную основания треугольника.

        :return: длину основания треугольника
        """
        return self.__base_length

    @base_length.setter
    def base_length(self, base_length: float) -> None:
        """Сеттер для проверки передаваемого значения base_length.

        :param:
            base_length длина основания треугольника

        :raise BaseException: В случае, если передаваемое значение меньше либо равно нулю, то вызывается исключение.
        """
        if base_length > 0:
            self.__base_length = base_length
        else:
            raise BaseException('Передаваемые значения должны быть больше нуля.')

    @property
    def altitude(self) -> float:
        """Геттер возвращает длинную высоты треугольника.

        :return: длину высоты треугольника
        """
        return self.__altitude

    @altitude.setter
    def altitude(self, altitude: float) -> None:
        """Сеттер для проверки передаваемого значения altitude.

        :param:
            altitude: длина высоты треугольника

        :raise BaseException: В случае, если передаваемое значение меньше либо равно нулю, то вызывается исключение.
        """
        if altitude > 0:
            self.__altitude = altitude
        else:
            raise BaseException('Передаваемые значения должны быть больше нуля.')

    def calculate_perimeter(self) -> float:
        """Переопределенный метод для вычисления периметра треугольника.

        :return: периметр треугольника
        """
        return (2 * sqrt((((self.base_length / 2) ** 2) + self.altitude ** 2))) + self.base_length

    def calculate_area(self) -> float:
        """Переопределенный метод для вычисления площади треугольника.

        :return: площадь треугольника
        """
        return (((self.base_length / 2) * self.altitude) / 2) * 2


class CalculateAreaMixin:
    """Класс-примесь, содержащий метод ля расчета площади куба и пирамиды."""

    @classmethod
    def calculate_all_area(cls, surfaces: list[Any]) -> float:
        """Метод для вычисления площади куба или пирамиды.

        :param:
            surfaces: список, содержащий площади отдельных поверхностей куба или пирамиды.

        :return: площадь куба или пирамиды
        """
        if len(surfaces) == 6:          # если длина списка равна 6, то это куб, в противном случае пирамида.
            result = 6 * surfaces[0].calculate_area()
        else:
            result = ((1 / 2) * surfaces[0].altitude * surfaces[4].calculate_perimeter()) \
                     + surfaces[4].calculate_area()

        return result


class Cube(CalculateAreaMixin):
    """ Класс содержит класс-примесь CalculateAreaMixin.  Инициализирует объект куб.

    Args:
        side: длинна стороны квадрата (ребра куба)

    Attributes:
        __surface: название отдельной поверхности куба
        __surfaces: список площадей отдельных объектов-квадратов, из которых состоит куб
    """

    def __init__(self, side: float) -> None:
        """Магический метод для инициализации объекта куб.

        :param:
            side: длинна стороны квадрата (ребра куба)
        """
        self.surface = side
        self.__surfaces = [self.surface for _ in range(6)]

    @property
    def surfaces(self) -> list[Square]:
        """Геттер возвращает список отдельных объектов-квадратов, из которых состоит куб.

        :return: список отдельных объектов-квадратов
        """
        return self.__surfaces

    @property
    def surface(self) -> Square:
        """Геттер возвращает отдельный объект-квадрат, входящего в состав инициализируемого куба.

        :return: название отдельного объекта-квадрата
        """
        return self.__surface

    @surface.setter
    def surface(self, side: float) -> None:
        """Сеттер для проверки передаваемого значения side.

        :param:
            side: длинна стороны квадрата (ребра куба)

        :raise BaseException: В случае, если передаваемое значение меньше либо равно нулю, то вызывается исключение.
        """
        if side > 0:
            self.__surface = Square(side)
        else:
            raise BaseException('Передаваемые значения должны быть больше нуля.')


class Pyramid(CalculateAreaMixin):
    """ Класс содержит класс-примесь CalculateAreaMixin.  Инициализирует объект пирамида.

    Args:
        base_length: длина основания треугольника
        altitude: длина высоты треугольника
        side: длинна стороны квадрата

    Attributes:
        __surface_triangle: отдельная боковая поверхность пирамиды
        __surface_square: основание пирамиды
        __surfaces: список отдельных объектов-треугольников и отдельного объекта-квадрата, из которых состоит пирамида.
    """

    def __init__(self, base_length: float, altitude: float, side: float) -> None:
        """Магический метод для инициализации объекта пирамида.

        :param:
            base_length: длина основания треугольника
            altitude: длина высоты треугольника
            side: длинна стороны квадрата
        """
        self.surface_triangle = base_length, altitude
        self.surface_square = side
        self.__surfaces = [self.surface_triangle if num != 4 else self.surface_square for num in range(5)]

    @property
    def surfaces(self) -> list[Any]:
        """Геттер возвращает список отдельных объектов-треугольников, из которых состоит пирамида.

        :return: список площадей отдельных объектов-треугольников
        """
        return self.__surfaces

    @property
    def surface_square(self) -> Square:
        """Геттер возвращает объект-квадрат, который является основанием пирамиды.

        :return: объект-квадрат
        """
        return self.__surface_square

    @surface_square.setter
    def surface_square(self, side: float) -> None:
        """Сеттер для проверки передаваемого значения side.

        :param:
            side: длинна стороны квадрата

        :raise BaseException: В случае, если передаваемое значение меньше либо равно нулю, то вызывается исключение.
        """
        if side > 0:
            self.__surface_square = Square(side)
        else:
            raise BaseException('Передаваемые значения должны быть больше нуля.')

    @property
    def surface_triangle(self) -> Triangle:
        """Геттер возвращает отдельный объект-треугольник, входящий в состав инициализируемой пирамиды.

        :return: название отдельного объекта-треугольника
        """
        return self.__surface_triangle

    @surface_triangle.setter
    def surface_triangle(self, values: tuple[float, float]) -> None:
        """Сеттер для проверки передаваемого значения values (кортеж двух значений float (base_length, altitude)).

        :param:
            values (кортеж двух значений float (base_length (длина основания треугольника),
            altitude (длина высоты треугольника))

        :raise BaseException: В случае, если передаваемое значение меньше либо равно нулю, то вызывается исключение.
        """
        if values[0] > 0 and values[1] > 0:
            self.__surface_triangle = Triangle(values[0], values[1])
        else:
            raise BaseException('Передаваемые значения должны быть больше нуля.')


 
 ****************************************
 
 from typing import Any


class Date:
    """Класс, конвертирующий строку даты в объект класса,
    состоящего из соответствующих числовых значений дня, месяца и года

    __objects_of_date (list[str, str, str]) список из элементов, из которых состоит дата (изначально None)

    Attributes:
        __date_lst (list[str, str, str]) список из элементов, из которых состоит дата
    """
    __objects_of_date = None

    @classmethod
    def __init__(cls) -> None:
        """Метод, инициализирующий экземпляр класса."""
        cls.__date_lst = cls.__objects_of_date

    def __str__(self) -> str:
        """Магический метод, отображающий экземпляр класса в виде строки

        :return: строка даты вида: День: n Месяц: n Год: n
        """
        return 'День: {0}\t\t\tМесяц: {1}\t\t\tГод: {2}'.format(
                self.__date_lst[0],
                self.__date_lst[1],
                self.__date_lst[2]
            )

    @classmethod
    def convert_from_string(cls, date_str: str) -> Any:
        """Метод, конвертирующий строку даты в экземпляр класса.

        :return: экземпляр класса либо строку о некорректности введенных данных
        """
        valid = cls.is_date_valid(date_str)
        if valid:
            cls.__objects_of_date = date_str.split('-')
            return Date()
        else:
            return 'Некорректная дата! Невозможно провести конвертацию.'

    @classmethod
    def is_date_valid(cls, date_str: str) -> bool:
        """Метод, проверяющий числа даты на корректность

        :return: True - если дата корректна, False - если нет
        :except IndexError, ValueError: эти два исключения вызываются в случае ввода
         некоторых вариантов некорректной строки даты и призваны обеспечить нормальную работу программы
        """
        valid = False
        date_lst = date_str.split('-')
        if len(date_lst) == 3:
            try:
                if date_lst[0][0] == '0':
                    date_lst[0] = date_lst[0][1]
                elif date_lst[1][0] == '0':
                    date_lst[1] = date_lst[1][1]
                if int(date_lst[0]) in range(1, 32) and int(date_lst[1]) in [1, 3, 5, 7, 8, 10, 12] \
                        and int(date_lst[2]) in range(1596, 2100):
                    valid = True
                elif int(date_lst[0]) in range(1, 31) and int(date_lst[1]) in [4, 6, 9, 11]\
                        and int(date_lst[2]) in range(1596, 2100):
                    valid = True
                elif int(date_lst[0]) in range(1, 29) and int(date_lst[1]) == 2 and int(date_lst[2])\
                        in range(1596, 2100):
                    valid = True
                elif (int(date_lst[0]) in range(1, 30) and int(date_lst[1]) == 2 and int(date_lst[2])
                      in range(1596, 1700, 4))\
                        or (int(date_lst[0]) in range(1, 30) and int(date_lst[1]) == 2 and int(date_lst[2])
                            in range(1704, 1800, 4))\
                        or (int(date_lst[0]) in range(1, 30) and int(date_lst[1]) == 2 and int(date_lst[2])
                            in range(1804, 1900, 4)) \
                        or (int(date_lst[0]) in range(1, 30) and int(date_lst[1]) == 2 and int(date_lst[2])
                            in range(1904, 2000, 4)) \
                        or (int(date_lst[0]) in range(1, 30) and int(date_lst[1]) == 2 and int(date_lst[2])
                            in range(2004, 2100, 4)):
                    valid = True

                if valid:
                    return True
                else:
                    return False
            except (IndexError, ValueError):
                pass
        else:
            return False


# Программа определит правильность соотношения количества дней в месяцах с 1596 по 2099 гг. Такой диапазон обусловлен
# календарем високосных годов, который мне удалось найти в интернете - с 1600 по 2400.
# Чтобы сократить размер кода, я сократил этот диапазон до 2099 г.


data = Date.convert_from_string('31-03-2022')
print(data)
print(Date.is_date_valid('10-12-2077'))
print(Date.is_date_valid('29-02-2022'))

 
 ****************************************
 
 